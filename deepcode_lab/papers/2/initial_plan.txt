I'll now synthesize both comprehensive analyses into a complete implementation reproduction plan for the Observability Monitoring Platform.

```yaml
complete_reproduction_plan:
  paper_info:
    title: "Observability Monitoring Platform - Comprehensive Frontend Demo System"
    core_contribution: "Integrated multi-dimensional observability visualization (metrics, traces, logs) with seamless cross-module navigation for rapid fault localization"
    project_type: "Frontend UI/UX System - Vue 3 + TypeScript + Mock Data"
    implementation_scope: "100% client-side, no backend required"
    complexity_level: "High (47 components, 5 modules, 3 data generators, 11 phases)"

  ============================================================================
  SECTION 1: FILE STRUCTURE DESIGN
  ============================================================================

  file_structure: |
    observability-monitoring-platform/
    ├── README.md                               # Setup, features, mock data architecture
    ├── CHANGELOG.md                            # Feature and update history
    ├── package.json                            # Dependencies and build scripts
    ├── vite.config.ts                          # Vite configuration (HMR, build)
    ├── tsconfig.json                           # TypeScript (strict mode: true)
    ├── eslintrc.json                           # Linting rules for code quality
    ├── .prettierrc.json                        # Code formatting standards
    ├── .gitignore                              # Git exclusions
    │
    ├── public/
    │   ├── index.html                          # Main HTML entry point
    │   └── favicon.ico                         # Browser favicon
    │
    ├── src/
    │   ├── main.ts                             # App initialization, Pinia, Router
    │   ├── App.vue                             # Root component, global layout
    │   │
    │   ├── views/                              # Page-level components (one per route)
    │   │   ├── Dashboard.vue                   # Overview Dashboard (健康板 + KPI + 告警 + 趋势图)
    │   │   ├── Metrics.vue                     # Metrics Monitoring (服务列表 + 多维度指标 + 对比)
    │   │   ├── Tracing.vue                     # Distributed Tracing (列表 + 拓扑 + Span详情)
    │   │   ├── Logs.vue                        # Log Analytics (日志流 + 搜索 + 统计)
    │   │   └── Custom.vue                      # Custom Dashboard (拖拽 + 配置 + 模板)
    │   │
    │   ├── components/                         # Reusable UI components
    │   │   ├── Charts/
    │   │   │   ├── LineChart.vue               # Time-series visualization
    │   │   │   ├── BarChart.vue                # Comparative metrics
    │   │   │   ├── PieChart.vue                # Distribution (log levels, etc)
    │   │   │   ├── HeatmapChart.vue            # Time-intensity heatmap
    │   │   │   ├── GaugeChart.vue              # Current values with thresholds
    │   │   │   ├── FlameGraph.vue              # Trace flamechart (spans)
    │   │   │   ├── GanttChart.vue              # Timeline for concurrent spans
    │   │   │   ├── ChartContainer.vue          # Responsive wrapper with toolbar
    │   │   │   ├── ChartLegend.vue             # Interactive legend toggle
    │   │   │   └── TopologyViewer.vue          # Service dependency graph (G6)
    │   │   │
    │   │   ├── Filters/
    │   │   │   ├── FilterBar.vue               # Multi-dimensional filter UI
    │   │   │   ├── ServiceFilter.vue           # Service/app dropdown
    │   │   │   ├── EnvironmentFilter.vue       # Prod/Staging/Test
    │   │   │   ├── RegionFilter.vue            # Region/Zone hierarchical
    │   │   │   ├── InstanceFilter.vue          # Instance ID autocomplete
    │   │   │   └── TagFilter.vue               # Custom key-value tags
    │   │   │
    │   │   ├── TimePicker/
    │   │   │   ├── TimeRangePicker.vue         # Main time control container
    │   │   │   ├── QuickTimeSelect.vue         # Preset buttons (5m-7d)
    │   │   │   ├── CustomDateTimeRange.vue     # Date + time pickers
    │   │   │   ├── RealtimeToggle.vue          # Real-time mode + interval
    │   │   │   └── TimeComparison.vue          # Compare with previous period
    │   │   │
    │   │   ├── Alerts/
    │   │   │   ├── AlertPanel.vue              # Active alerts (Dashboard)
    │   │   │   ├── AlertHistory.vue            # Historical alert records
    │   │   │   ├── AlertRuleList.vue           # Configured rules display
    │   │   │   └── AlertDetail.vue             # Full alert context view
    │   │   │
    │   │   ├── Layout/
    │   │   │   ├── Header.vue                  # Top bar (time + filters + alerts)
    │   │   │   ├── Sidebar.vue                 # Left navigation menu
    │   │   │   ├── MainLayout.vue              # Two-column wrapper
    │   │   │   ├── PageContent.vue             # Scrollable main area
    │   │   │   └── Breadcrumbs.vue             # Navigation context
    │   │   │
    │   │   └── Common/
    │   │       ├── LoadingSkeleton.vue         # Pulsing skeleton screens
    │   │       ├── EmptyState.vue              # No-data message with icon
    │   │       ├── ErrorState.vue              # Error display + retry button
    │   │       ├── ConfirmDialog.vue           # Modal confirmation
    │   │       └── InfoDrawer.vue              # Side information panel
    │   │
    │   ├── composables/                        # Composition API functions (reusable logic)
    │   │   ├── useTimeRange.ts                 # Time range state + quick presets
    │   │   ├── useFilters.ts                   # Filter state + persistence
    │   │   ├── useChartTheme.ts                # ECharts theme config
    │   │   ├── useMetrics.ts                   # Metrics data fetching + aggregation
    │   │   ├── useTraces.ts                    # Trace data + filtering
    │   │   ├── useLogs.ts                      # Log search + virtual scroll
    │   │   ├── useAlerts.ts                    # Alert data + rules
    │   │   ├── usePagination.ts                # Reusable pagination logic
    │   │   ├── useRealtime.ts                  # Auto-refresh in real-time mode
    │   │   ├── useDashboardLayout.ts           # Drag-drop grid management
    │   │   └── useLocalStorage.ts              # Persistent storage helper
    │   │
    │   ├── stores/                             # Pinia state management (global state)
    │   │   ├── timeStore.ts                    # Global time state (start, end, mode)
    │   │   ├── filterStore.ts                  # Global filter state
    │   │   ├── metricsStore.ts                 # Cached metrics data
    │   │   ├── tracesStore.ts                  # Cached trace data
    │   │   ├── logsStore.ts                    # Cached log data
    │   │   ├── alertsStore.ts                  # Alert rules + events
    │   │   ├── dashboardStore.ts               # Saved dashboard configs
    │   │   └── uiStore.ts                      # UI state (theme, modals, sidebar)
    │   │
    │   ├── mock/                               # Mock data generation system
    │   │   ├── index.ts                        # Initialization (startup hook)
    │   │   ├── services.ts                     # Service definitions (3 services)
    │   │   ├── constants.ts                    # Mock data constants
    │   │   │
    │   │   ├── generators/                     # Data generation algorithms
    │   │   │   ├── timeSeriesGenerator.ts      # ALGORITHM: Sine wave + noise
    │   │   │   ├── traceGenerator.ts           # ALGORITHM: Random call chains
    │   │   │   ├── logGenerator.ts             # ALGORITHM: Poisson distribution
    │   │   │   ├── alertGenerator.ts           # Alert rule + event generation
    │   │   │   └── utils.ts                    # Helper: random, gaussian, uuid
    │   │   │
    │   │   ├── data/                           # Pre-generated sample data
    │   │   │   ├── metrics.ts                  # Metric samples (24h history)
    │   │   │   ├── traces.ts                   # Trace samples (100 traces)
    │   │   │   └── logs.ts                     # Log samples (10,000 entries)
    │   │   │
    │   │   └── api.ts                          # Mock API endpoints (HTTP simulation)
    │   │
    │   ├── services/                           # Business logic layer
    │   │   ├── metricsService.ts               # Metric aggregation + filtering
    │   │   ├── tracesService.ts                # Trace analysis + slow detection
    │   │   ├── logsService.ts                  # Log search + field extraction
    │   │   ├── alertsService.ts                # Alert evaluation + correlation
    │   │   ├── dashboardService.ts             # Dashboard persistence
    │   │   └── storageService.ts               # LocalStorage management
    │   │
    │   ├── router/                             # Vue Router configuration
    │   │   └── index.ts                        # Route definitions + guards
    │   │
    │   ├── types/                              # TypeScript type definitions
    │   │   ├── index.ts                        # Export all types
    │   │   ├── metrics.ts                      # MetricPoint, TimeSeries types
    │   │   ├── traces.ts                       # Trace, Span, TraceID types
    │   │   ├── logs.ts                         # LogEntry, LogLevel types
    │   │   ├── alerts.ts                       # AlertRule, AlertEvent types
    │   │   ├── filters.ts                      # FilterSet, FilterValue types
    │   │   ├── dashboard.ts                    # DashboardConfig, Widget types
    │   │   └── api.ts                          # API response types
    │   │
    │   ├── utils/                              # Utility functions
    │   │   ├── formatters.ts                   # Date/time, number formatting
    │   │   ├── calculations.ts                 # Percentile, aggregation math
    │   │   ├── validators.ts                   # Input validation rules
    │   │   ├── chart-config.ts                 # ECharts option templates
    │   │   ├── color-palette.ts                # Color scheme definitions
    │   │   ├── localStorage.ts                 # Safe LocalStorage wrapper
    │   │   └── constants.ts                    # App-wide constants
    │   │
    │   ├── styles/                             # Global styling (SCSS)
    │   │   ├── main.scss                       # Entry point (imports all)
    │   │   ├── variables.scss                  # Design tokens (colors, spacing, typography)
    │   │   ├── themes/
    │   │   │   ├── dark.scss                   # Dark theme (primary)
    │   │   │   └── light.scss                  # Light theme (optional future)
    │   │   ├── components.scss                 # Component-specific styles
    │   │   ├── animations.scss                 # Keyframes + transitions
    │   │   ├── responsive.scss                 # Media queries (1920px+)
    │   │   └── reset.scss                      # Normalize + base resets
    │   │
    │   └── assets/
    │       ├── images/                         # SVG/PNG graphics
    │       └── icons/                          # Icon sprite sheets
    │
    ├── tests/
    │   ├── unit/
    │   │   ├── generators.spec.ts              # Test data generators
    │   │   ├── composables.spec.ts             # Test composable functions
    │   │   ├── services.spec.ts                # Test business logic
    │   │   └── filters.spec.ts                 # Test filter algorithms
    │   │
    │   └── integration/
    │       ├── workflows.spec.ts               # End-to-end workflow tests
    │       └── cross-module.spec.ts            # Module linkage tests
    │
    └── docs/                                   # Documentation files
        ├── ARCHITECTURE.md                     # System overview + design
        ├── MOCK_DATA.md                        # Generator algorithms + configs
        ├── COMPONENT_GUIDE.md                  # Component APIs + usage
        ├── STYLING_GUIDE.md                    # Design system + theming
        └── DEPLOYMENT.md                       # Build + deploy guide

  FILE_PRIORITY_IMPLEMENTATION_ORDER:
    TIER_1_CORE_ALGORITHMS:
      - "src/mock/generators/timeSeriesGenerator.ts" (foundation)
      - "src/mock/generators/traceGenerator.ts" (foundation)
      - "src/mock/generators/logGenerator.ts" (foundation)
      - "src/types/index.ts" (all type definitions)
    
    TIER_2_STATE_MANAGEMENT:
      - "src/stores/timeStore.ts"
      - "src/stores/filterStore.ts"
      - "src/stores/metricsStore.ts"
      - "src/stores/tracesStore.ts"
      - "src/stores/logsStore.ts"
    
    TIER_3_COMPOSABLES:
      - "src/composables/useTimeRange.ts"
      - "src/composables/useFilters.ts"
      - "src/composables/useChartTheme.ts"
      - "src/composables/useMetrics.ts"
      - "src/composables/useLogs.ts"
    
    TIER_4_UI_COMPONENTS:
      - "src/components/Layout/MainLayout.vue" (foundation)
      - "src/components/Charts/LineChart.vue"
      - "src/components/Charts/BarChart.vue"
      - "src/components/Charts/PieChart.vue"
      - All chart variants
      - All filter components
      - All time picker components
    
    TIER_5_PAGE_VIEWS:
      - "src/views/Dashboard.vue"
      - "src/views/Metrics.vue"
      - "src/views/Tracing.vue"
      - "src/views/Logs.vue"
      - "src/views/Custom.vue"
    
    TIER_6_ADVANCED_FEATURES:
      - "src/composables/useDashboardLayout.ts"
      - Cross-module navigation
      - Custom dashboard drag-drop
    
    TIER_7_DOCUMENTATION_LAST:
      - "README.md" (project overview + setup)
      - "CHANGELOG.md" (features + updates)
      - All docs/ files (implementation guides)

  ============================================================================
  SECTION 2: IMPLEMENTATION COMPONENTS
  ============================================================================

  implementation_components: |
    
    ================================================================================
    CORE LAYER 1: MOCK DATA GENERATION ALGORITHMS (Foundation)
    ================================================================================
    
    ALGORITHM_1_TIME_SERIES_GENERATOR:
      File: "src/mock/generators/timeSeriesGenerator.ts"
      Purpose: "Generate realistic metric time-series with natural patterns"
      
      Core Formula:
        value(t) = baseValue + amplitude*sin(2π*t/period) + noise(t) + trend*t + anomaly(t)
      
      Parameters:
        baseValue: number           # Average metric value (e.g., 50 for CPU%)
        amplitude: number           # Oscillation magnitude (e.g., ±20)
        period: number (minutes)    # Sine wave period (typical: 5-60 min)
        noise: number (0-1)         # Random variation coefficient
        trend: number/minute        # Linear drift (can be negative)
        anomalyProb: number (0-1)   # Spike probability (typical: 0.01-0.05)
        anomalyMag: number          # Spike magnitude multiplier
      
      Implementation Pseudocode:
        function generateTimeSeries(config):
          points = []
          periodMs = config.period * 60 * 1000
          
          for t from startTime to endTime by intervalSeconds:
            // Sine component (daily/hourly pattern)
            sine = baseValue + amplitude * sin(2π * timeElapsed / periodMs)
            
            // Gaussian noise (random variation)
            noise = (random() - 0.5) * 2 * baseValue * noiseLevel
            
            // Trend (gradual increase/decrease)
            trend = trendRate * (timeElapsed / 60000)  // convert to minutes
            
            // Anomaly spike (occasional outlier)
            anomaly = 0
            if random() < anomalyProbability:
              anomaly = baseValue * anomalyMagnitude * random()
            
            value = sine + noise + trend + anomaly
            value = clamp(value, minValue, maxValue)  // Realistic bounds
            
            points.append({timestamp: t, value: value})
          
          return points
      
      Example Configurations:
        CPU_USAGE:
          baseValue: 50          # 50%
          amplitude: 20          # ±20%
          period: 5              # 5-minute oscillation
          noise: 0.1             # 10% variation
          trend: 0.1             # +0.1% per minute
          anomalyProb: 0.05      # 5% spike probability
          anomalyMag: 3          # 3x baseline spike
          minValue: 0, maxValue: 100
        
        ERROR_RATE:
          baseValue: 0.5         # 0.5%
          amplitude: 0.3         # ±0.3%
          period: 10             # 10-minute oscillation
          noise: 0.1             # 10% variation
          trend: 0               # No trend
          anomalyProb: 0.02      # 2% spike probability
          anomalyMag: 5          # 5x baseline spike
          minValue: 0, maxValue: 10
        
        RESPONSE_TIME:
          baseValue: 100         # 100ms
          amplitude: 30          # ±30ms
          period: 8              # 8-minute oscillation
          noise: 0.15            # 15% variation
          trend: 2               # +2ms per minute (degradation)
          anomalyProb: 0.01      # 1% spike probability
          anomalyMag: 10         # 10x baseline spike
          minValue: 10, maxValue: 5000
      
      Helper Functions:
        gaussian(mu=0, sigma=1): number
          // Box-Muller transform for Gaussian distribution
          u1 = random()
          u2 = random()
          z = sqrt(-2 * ln(u1)) * cos(2π * u2)
          return mu + sigma * z
        
        exponentialRandom(min, max): number
          // Exponential distribution (skewed towards small values)
          random = Math.random()
          exp = Math.exp(-5 * random)
          return min + exp * (max - min)
      
      Output Data Structure:
        MetricPoint {
          timestamp: ISO8601 DateTime
          value: number
          min: number (optional, for aggregated buckets)
          max: number (optional, for aggregated buckets)
        }
        
        TimeSeries {
          metricId: string
          metricName: string
          unit: string (%, ms, Mbps, etc)
          serviceId: string
          dataPoints: MetricPoint[]
          lastUpdate: DateTime
        }
      
      Volume Capability:
        - Single series: 10,000+ points
        - Dashboard with 20 charts: 200,000+ points total
        - Memory footprint: ~5MB for 100,000 points
        - Render time: <500ms for 1000-point series
    
    ================================================================================
    ALGORITHM_2_TRACE_GENERATOR:
      File: "src/mock/generators/traceGenerator.ts"
      Purpose: "Generate distributed tracing data with realistic service call chains"
      
      Core Concept: Random tree generation with parent-child span relationships
      
      Algorithm Pseudocode:
        function generateTrace(config):
          traceId = generateUUID()
          rootService = selectRandomService(config.services)
          
          rootSpan = createSpan({
            traceId: traceId,
            parentSpanId: null,
            service: rootService,
            operation: "entry-point",
            duration: exponentialRandom(10, 50),  // Root usually fast
            status: "success"
          })
          
          trace = new Trace(traceId, rootSpan)
          
          // Build call chain recursively
          buildCallChain(trace, rootSpan, config, maxDepth=10)
          
          return trace
        
        function buildCallChain(trace, parentSpan, config, depth):
          if depth == 0:
            return  // Stop recursion
          
          branchCount = randomInt(1, 3)  // Each service calls 1-3 downstream
          
          for i in 1..branchCount:
            // Select downstream service (avoid self-calls)
            service = selectRandomService(
              exclude=parentSpan.service,
              services=config.services
            )
            
            // Determine status (95% success, 5% error)
            hasError = random() < config.errorRate
            
            childSpan = createSpan({
              traceId: trace.id,
              parentSpanId: parentSpan.id,
              service: service,
              operation: selectRandomOperation(service),
              duration: exponentialRandom(20, 500),  // Service call
              status: hasError ? "ERROR" : "SUCCESS",
              tags: generateTags(service),  // Metadata
              logs: generateLogs(hasError)  // Associated logs
            })
            
            trace.addSpan(childSpan)
            
            // Continue recursively to next level
            if random() < 0.7:  // 70% chance of deeper calls
              buildCallChain(trace, childSpan, config, depth-1)
      
      Parameters:
        services: ServiceDefinition[]        # Service pool
        minDepth: number                     # Minimum span levels (typical: 3)
        maxDepth: number                     # Maximum span levels (typical: 10)
        errorRate: number (0-1)              # Probability of error (typical: 0.05)
        durationMinMs: number                # Minimum span duration (typical: 10)
        durationMaxMs: number                # Maximum span duration (typical: 500)
        branchProbability: number            # Depth continuation prob (typical: 0.7)
      
      Output Data Structure:
        Trace {
          traceId: string (UUID)
          rootSpanId: string
          rootService: string
          startTime: DateTime
          endTime: DateTime
          totalDurationMs: number
          spanCount: number
          status: "SUCCESS" | "ERROR" | "TIMEOUT"
          spans: Span[]
        }
        
        Span {
          spanId: string (UUID)
          traceId: string (UUID)
          parentSpanId: string | null
          service: string
          operation: string
          startTime: DateTime
          endTime: DateTime
          durationMs: number
          status: "SUCCESS" | "ERROR" | "TIMEOUT"
          tags: Record<string, any>           # Metadata (host, user, etc)
          logs: SpanLog[]                     # Log entries during span
        }
        
        SpanLog {
          timestamp: DateTime
          message: string
          fields: Record<string, any>
        }
      
      Example Output (3-level trace):
        Trace {
          traceId: "abc-123",
          spans: [
            // Root span (API Gateway)
            Span {
              spanId: "span-1",
              service: "api-gateway",
              operation: "POST /api/users",
              duration: 145ms,
              status: "SUCCESS"
            },
            // Level 1 children
            Span {
              spanId: "span-2",
              parentSpanId: "span-1",
              service: "auth-service",
              operation: "validate-token",
              duration: 25ms,
              status: "SUCCESS"
            },
            Span {
              spanId: "span-3",
              parentSpanId: "span-1",
              service: "user-service",
              operation: "create-user",
              duration: 100ms,
              status: "SUCCESS"
            },
            // Level 2 children
            Span {
              spanId: "span-4",
              parentSpanId: "span-3",
              service: "database",
              operation: "INSERT users",
              duration: 80ms,
              status: "SUCCESS"
            },
            Span {
              spanId: "span-5",
              parentSpanId: "span-3",
              service: "cache-service",
              operation: "SET user:123",
              duration: 15ms,
              status: "SUCCESS"
            }
          ]
        }
      
      Volume Capability:
        - Traces per generation: 50-100 traces at startup
        - Spans per trace: 3-20 spans (average: ~10)
        - Total spans generated: 500-1000 spans
        - Memory footprint: ~2MB for 1000 traces
        - Real-time generation: Add 1-5 new traces per 10 seconds
    
    ================================================================================
    ALGORITHM_3_LOG_GENERATOR:
      File: "src/mock/generators/logGenerator.ts"
      Purpose: "Generate realistic log streams with time-based density variation"
      
      Core Concept: Poisson process for inter-arrival times, density varies by time-of-day
      
      Algorithm Pseudocode:
        function generateLogs(config):
          logs = []
          currentTime = config.startTime
          isErrorCluster = false
          clusterEndTime = currentTime
          
          while currentTime < config.endTime:
            // Determine log frequency based on time of day
            hourUTC = currentTime.getUTCHours()
            isPeakHour = isPeakHour(hourUTC, config.peakHours)
            
            baseDensity = config.baseFrequencyPerMinute  // logs/min
            densityMultiplier = isPeakHour ? 1.5 : 0.3   // Business hours vs off-hours
            
            // Poisson inter-arrival time
            interArrivalSeconds = poissonRandom(baseDensity * densityMultiplier) * 60
            currentTime += interArrivalSeconds
            
            // Error clustering (occasional error bursts)
            if random() < 0.01:  // 1% chance to start cluster
              isErrorCluster = true
              clusterEndTime = currentTime + randomInt(5, 15) * 60000
            
            if currentTime > clusterEndTime:
              isErrorCluster = false
            
            // Determine log level with bias towards errors during clusters
            errorRate = isErrorCluster ? config.errorRatePeak : config.errorRateNormal
            logLevel = selectLogLevel(errorRate)  // DEBUG, INFO, WARN, ERROR, FATAL
            
            // Select source service
            service = selectRandomService(config.services)
            
            // Create log entry
            log = LogEntry {
              id: generateUUID(),
              timestamp: currentTime,
              service: service.name,
              level: logLevel,
              message: generateMessage(service, logLevel),
              traceId: random() < config.traceIdProbability ? generateTraceId() : null,
              context: {
                userId: randomInt(1, 10000),
                requestId: generateUUID(),
                instanceId: service.instances[randomInt(0, service.instances.length-1)]
              }
            }
            
            logs.append(log)
          
          return logs.sort((a, b) => a.timestamp - b.timestamp)
        
        function poissonRandom(lambda):
          // Knuth's algorithm for Poisson distribution
          L = exp(-lambda)
          k = 0
          p = 1
          
          do:
            k = k + 1
            p = p * random()
          while p > L
          
          return k - 1
        
        function selectLogLevel(errorRate):
          random = random()
          
          if random < errorRate * 0.7:
            return "ERROR"         // 70% of errors
          else if random < errorRate * 0.85:
            return "WARN"          // 15% of errors
          else if random < errorRate + 0.3:
            return "INFO"          // Main log type
          else if random < errorRate + 0.5:
            return "DEBUG"         // Detailed debugging
          else:
            return "FATAL"         // Rare critical failures
      
      Parameters:
        services: ServiceDefinition[]           # Service pool
        timeRange: DateRange                    # Start and end times
        baseFrequencyPerMinute: number          # Baseline logs/minute (typical: 10)
        peakHours: [number, number][]           # UTC hours with higher frequency
        errorRateNormal: number (0-1)           # Error probability normal (typical: 0.005)
        errorRatePeak: number (0-1)             # Error probability in cluster (typical: 0.1)
        traceIdProbability: number (0-1)        # % of logs with traceId (typical: 0.2)
      
      Density Function:
        // Business hours (9-12, 14-17 UTC): 1.5x baseline
        // Night hours (0-7 UTC): 0.3x baseline
        // Weekend: 0.6x baseline
        
        calculateDensity(timestamp, config):
          hourUTC = timestamp.getUTCHours()
          dayOfWeek = timestamp.getUTCDay()
          
          isBusinessHour = (hourUTC >= 9 && hourUTC < 12) ||
                          (hourUTC >= 14 && hourUTC < 17)
          isNightHour = hourUTC >= 0 && hourUTC < 7
          isWeekend = dayOfWeek == 0 || dayOfWeek == 6
          
          multiplier = 1.0
          if isBusinessHour:
            multiplier = 1.5
          else if isNightHour:
            multiplier = 0.3
          else if isWeekend:
            multiplier = 0.6
          
          return config.baseFrequencyPerMinute * multiplier
      
      Output Data Structure:
        LogEntry {
          id: string (UUID)
          timestamp: DateTime
          service: string
          level: "DEBUG" | "INFO" | "WARN" | "ERROR" | "FATAL"
          message: string
          traceId: string | null                # Link to trace if applicable
          spanId: string | null                 # Link to span if applicable
          context: {
            userId: number
            requestId: string
            instanceId: string
            environment: string
            region: string
          }
          stacktrace: string | null             # Error stack trace
        }
      
      Message Templates by Level:
        DEBUG: [
          "Method {method} called with params {params}",
          "Cache hit for key {key}",
          "Database connection pool available: {count}"
        ]
        
        INFO: [
          "Request {id} received from {source}",
          "User {userId} logged in successfully",
          "Batch job {jobId} started",
          "Service health check passed for {service}"
        ]
        
        WARN: [
          "Retry attempt {attempt}/{max} for operation {op}",
          "High memory usage: {percent}%",
          "API response time elevated: {ms}ms",
          "Database connection slow: {ms}ms"
        ]
        
        ERROR: [
          "Failed to connect to database: {error}",
          "Timeout on API call to {service}: {ms}ms",
          "Authentication failed for user {userId}",
          "Payment processing failed: {error}"
        ]
        
        FATAL: [
          "Critical service degradation detected",
          "Data corruption detected in {component}",
          "System out of memory, shutting down",
          "Unrecoverable error in core component"
        ]
      
      Volume Capability:
        - Logs generated per 24h: 100,000+ entries (varies by service)
        - High-traffic service: 10,000+ logs/hour = 240,000/day
        - Normal service: 1,000-5,000 logs/hour = 24,000-120,000/day
        - Low-traffic service: 100-500 logs/hour = 2,400-12,000/day
        - Total for 3 services: 300,000-370,000 logs/24h
        - Virtual scrolling allows rendering 10,000+ visible logs
        - Memory footprint: ~50MB for 24h of logs across 3 services
    
    ================================================================================
    CORE LAYER 2: STATE MANAGEMENT (Pinia Stores)
    ================================================================================
    
    PINIA_STORE_TIME:
      File: "src/stores/timeStore.ts"
      Purpose: "Global time range state (shared across all modules)"
      
      State:
        startTime: Ref<Date>              # Start of time range
        endTime: Ref<Date>                # End of time range
        selectedPreset: Ref<TimePreset>   # Which preset selected ('last_1h', 'custom', etc)
        realTimeMode: Ref<boolean>        # Auto-advance mode
        refreshInterval: Ref<number>      # Seconds between updates
      
      Computed:
        durationMs: number                # (endTime - startTime) in milliseconds
        formattedRange: string            # "2024-01-15 14:30 - 2024-01-15 15:30"
        isRealTime: boolean               # realTimeMode && refreshInterval > 0
      
      Actions:
        setTimeRange(start: Date, end: Date)  # Set custom range
        applyPreset(preset: TimePreset)       # Apply quick preset
        toggleRealTime()                      # Turn real-time on/off
        setRefreshInterval(seconds: number)   # Update refresh speed
        getComparisonRange(mode: string)      # Get previous period for comparison
      
      Getters:
        timeRangeMinutes: number          # Duration in minutes
        isPastWeek: boolean               # True if range > 7 days
      
      Watchers:
        // Trigger data refresh when time changes
        watch(startTime, () => {
          // Signal all stores to refresh data
          emit('time-changed')
        })
    
    PINIA_STORE_FILTERS:
      File: "src/stores/filterStore.ts"
      Purpose: "Global multi-dimensional filter state"
      
      State:
        activeFilters: Ref<FilterSet>     # Current filters
        savedPresets: Ref<Array>          # User-saved filter combinations
      
      FilterSet Structure:
        service?: string[]                # Service names
        environment?: string[]            # ['production', 'staging', 'testing']
        region?: string[]                 # ['us-east-1', 'us-west-2', ...]
        instance?: string[]               # Instance IDs
        tags?: Record<string, string[]>   # Custom key-value tags
      
      Actions:
        setFilter(filterType, values)     # Add/update filter
        clearFilter(filterType)           # Remove specific filter
        clearAllFilters()                 # Reset all filters
        savePreset(name)                  # Save current filters
        loadPreset(name)                  # Load saved filters
        applyMultiple(filters)            # Apply several filters at once
      
      Persistence:
        // Save/load from LocalStorage
        localStorage['monitoring_filters_preset_' + presetName]
        localStorage['monitoring_filters_active']
      
      Validation:
        // Ensure filter values are valid
        onFilterChange: (filters) => {
          validateFilters(filters)
          emit('filters-changed', filters)
        }
    
    PINIA_STORE_METRICS:
      File: "src/stores/metricsStore.ts"
      Purpose: "Cached metrics data with refresh management"
      
      State:
        metrics: Ref<Record<string, TimeSeries>>  # metric_id -> data
        loading: Ref<boolean>
        lastUpdate: Ref<DateTime>
        error: Ref<Error | null>
      
      Actions:
        fetchMetrics(service, timeRange, filters)
        getMetricData(metricId): TimeSeries
        aggregateMetrics(points, maxPoints): aggregated_points
        clearMetrics()
        invalidateCache()
      
      Computed:
        metricCount: number               # Total metrics loaded
        isDirty: boolean                  # Needs refresh
        isEmpty: boolean                  # No data
    
    PINIA_STORE_TRACES:
      File: "src/stores/tracesStore.ts"
      Purpose: "Cached trace data with search/filter"
      
      State:
        traces: Ref<Trace[]>              # All traces
        selectedTrace: Ref<Trace | null>  # Currently viewed trace
        loading: Ref<boolean>
      
      Actions:
        fetchTraces(service, timeRange, filters, status)
        getTrace(traceId): Trace
        searchTraces(query): Trace[]
        detectSlowSpans(threshold): Span[]
      
      Computed:
        traceCount: number
        errorTraceCount: number
        avgDuration: number
    
    PINIA_STORE_LOGS:
      File: "src/stores/logsStore.ts"
      Purpose: "Cached log entries with search engine"
      
      State:
        logs: Ref<LogEntry[]>
        searchResults: Ref<LogEntry[]>
        currentQuery: Ref<string>
        loading: Ref<boolean>
      
      Actions:
        fetchLogs(service, timeRange, filters)
        search(query, filters)
        getLogContext(logId, contextSize): LogEntry[]
      
      Computed:
        totalLogs: number
        resultCount: number
        errorCount: number
        warningCount: number
    
    PINIA_STORE_ALERTS:
      File: "src/stores/alertsStore.ts"
      Purpose: "Alert rules and historical events"
      
      State:
        rules: Ref<AlertRule[]>          # Configured rules
        events: Ref<AlertEvent[]>        # Historical alerts
        activeCount: Ref<number>         # Currently active alerts
      
      Actions:
        fetchAlertRules()
        fetchAlertEvents(timeRange, severity)
        createAlert(rule): AlertEvent
        acknowledgeAlert(eventId)
      
      Computed:
        criticalCount: number            # Number of critical alerts
        warningCount: number
        infoCount: number
    
    ================================================================================
    CORE LAYER 3: COMPOSABLES (Reusable Logic)
    ================================================================================
    
    COMPOSABLE_USE_TIME_RANGE:
      File: "src/composables/useTimeRange.ts"
      Purpose: "Encapsulate time range logic (presets, custom, real-time)"
      
      Returns:
        timeRange: Ref<{start, end}>
        selectedPreset: Ref<string>
        realTimeMode: Ref<boolean>
        refreshInterval: Ref<number>
        
        applyPreset(name): void
        setCustomRange(start, end): void
        toggleRealTime(): void
        getFormattedRange(): string
        getComparisonRange(mode): DateRange
      
      Implementation Pattern:
        export function useTimeRange() {
          const timeStore = useTimeStore()
          
          // Ref to current preset (for UI binding)
          const selectedPreset = computed({
            get: () => timeStore.selectedPreset,
            set: (val) => timeStore.applyPreset(val)
          })
          
          // Auto-advance in real-time mode
          onMounted(() => {
            if (timeStore.realTimeMode) {
              const interval = setInterval(() => {
                const now = new Date()
                const duration = timeStore.endTime - timeStore.startTime
                timeStore.setTimeRange(
                  new Date(now - duration),
                  now
                )
              }, timeStore.refreshInterval * 1000)
              
              onUnmounted(() => clearInterval(interval))
            }
          })
          
          return { selectedPreset, timeRange, realTimeMode, ... }
        }
    
    COMPOSABLE_USE_FILTERS:
      File: "src/composables/useFilters.ts"
      Purpose: "Apply filters to data with smart caching"
      
      Returns:
        activeFilters: Ref<FilterSet>
        applyFilter(filterType, values): void
        getFilteredData<T>(data: T[], rules: FilterRuleMap): T[]
        savePreset(name): void
        loadPreset(name): void
      
      Filter Logic:
        // AND between filter types, OR within filter type
        data.filter(item => {
          return Object.entries(activeFilters).every(([type, values]) => {
            if (!values || values.length === 0) return true  // Not applied
            
            const rule = filterRules[type]
            return values.some(val => rule(item, val))  // OR logic
          })
        })
    
    COMPOSABLE_USE_CHART_THEME:
      File: "src/composables/useChartTheme.ts"
      Purpose: "Generate ECharts theme configuration"
      
      Returns:
        theme: Ref<ChartTheme>
        getChartOptions(baseOptions): echarts.EChartsOption
        getColorPalette(): string[]
        getTextStyle(): object
      
      Default Theme (Dark):
        background: '#0b0c0e'
        textColor: '#d8d9da'
        axisLineColor: 'rgba(255,255,255,0.2)'
        gridColor: 'rgba(255,255,255,0.1)'
        colors: ['#3274d9', '#73bf69', '#ff9830', '#f2495c', ...]
    
    COMPOSABLE_USE_METRICS:
      File: "src/composables/useMetrics.ts"
      Purpose: "Fetch and process metrics data"
      
      Parameters:
        service: Ref<string>
        timeRange: Ref<DateRange>
        filters: Ref<FilterSet>
      
      Returns:
        data: Ref<TimeSeries[]>
        loading: Ref<boolean>
        error: Ref<Error | null>
        refresh(): Promise
      
      Automatic Aggregation:
        // If > 1000 points, downsample to 500 points
        if (points.length > 1000) {
          const bucketSize = Math.ceil(points.length / 500)
          // Group into buckets, calculate min/max/avg
        }
    
    COMPOSABLE_USE_LOGS:
      File: "src/composables/useLogs.ts"
      Purpose: "Search and filter logs with virtual scrolling"
      
      Returns:
        logs: Ref<LogEntry[]>
        search(query): void
        getContext(logId, size): LogEntry[]
        canVirtualScroll: boolean
      
      Virtual Scrolling Optimization:
        // Only render visible items (50 visible + buffer)
        // Render 10,000+ items without lag
    
    COMPOSABLE_USE_DASHBOARD_LAYOUT:
      File: "src/composables/useDashboardLayout.ts"
      Purpose: "Manage drag-drop dashboard grid"
      
      Returns:
        widgets: Ref<DashboardWidget[]>
        addWidget(config): void
        removeWidget(id): void
        moveWidget(id, x, y): void
        resizeWidget(id, width, height): void
        saveLayout(): void
        undo(): void
        redo(): void
      
      Grid System:
        // 12-column grid
        // Min widget size: 2x2 units
        // Max widget size: 12x4 units
        // Save to LocalStorage on change (debounced 500ms)
    
    ================================================================================
    CORE LAYER 4: ALGORITHMS & SERVICES
    ================================================================================
    
    ALGORITHM_PERCENTILE_CALCULATION:
      File: "src/utils/calculations.ts"
      
      function calculatePercentile(values: number[], p: number): number {
        const sorted = [...values].sort((a, b) => a - b)
        const index = Math.ceil((p / 100) * sorted.length) - 1
        return sorted[Math.max(0, index)]
      }
      
      Usage: Calculate P50, P90, P99 latency
      
      Example:
        values = [10, 50, 100, 150, 200, 250, 300, 350, 400, 450, 500]
        P50 = calculatePercentile(values, 50) = 255ms
        P90 = calculatePercentile(values, 90) = 455ms
        P99 = calculatePercentile(values, 99) = 500ms
    
    ALGORITHM_SLOW_SPAN_DETECTION:
      File: "src/utils/traceAnalysis.ts"
      
      function detectSlowSpans(spans: Span[], threshold?: number): Span[] {
        const durations = spans.map(s => s.durationMs)
        const mean = avg(durations)
        const stdDev = standardDeviation(durations)
        
        // Mark as slow if > mean + 2*stdDev
        const slowThreshold = threshold || (mean + 2 * stdDev)
        
        return spans
          .filter(s => s.durationMs > slowThreshold)
          .sort((a, b) => b.durationMs - a.durationMs)
      }
      
      Use Case: Identify performance bottlenecks in trace
    
    ALGORITHM_LOG_FIELD_EXTRACTION:
      File: "src/utils/logParser.ts"
      
      function extractLogFields(
        message: string,
        patterns: Record<string, RegExp>
      ): Record<string, string> {
        const fields: Record<string, string> = {}
        
        for (const [fieldName, pattern] of Object.entries(patterns)) {
          const match = message.match(pattern)
          if (match) {
            fields[fieldName] = match[1]
          }
        }
        
        return fields
      }
      
      Example:
        message = "2024-01-15 14:30:45 ERROR - Connection failed to db:5432"
        patterns = {
          timestamp: /(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})/,
          level: /(\w+) -/,
          component: /to (\w+)/
        }
        Result: {
          timestamp: "2024-01-15 14:30:45",
          level: "ERROR",
          component: "db"
        }
    
    SERVICE_METRICS_SERVICE:
      File: "src/services/metricsService.ts"
      
      class MetricsService {
        getMetricsForService(service: string, timeRange: DateRange): TimeSeries[] {
          // Fetch from mock generator or cache
          // Apply filters
          // Aggregate if needed
        }
        
        compareServices(services: string[], metric: string): comparison_result {
          // Get metric data for all services
          // Calculate differences and percentage changes
        }
        
        calculateMetricStats(timeSeries: TimeSeries): MetricStats {
          // Min, max, avg, stdDev, P50, P90, P99
        }
      }
    
    SERVICE_LOGS_SERVICE:
      File: "src/services/logsService.ts"
      
      class LogsService {
        search(query: string, filters: FilterSet): LogEntry[] {
          // Parse query (keywords, regex, fields)
          // Apply filters (AND between types, OR within)
          // Return matching logs
        }
        
        getContext(logId: string, contextSize: number): LogEntry[] {
          // Return N logs before + after specified log
        }
        
        getStatistics(timeRange: DateRange): LogStatistics {
          // Count by level, count trend by time bucket
          // Return aggregated stats
        }
      }
    
    ================================================================================
    CORE LAYER 5: UI COMPONENTS
    ================================================================================
    
    COMPONENT_SET_CHARTS:
      All chart components follow same pattern:
      
      props:
        data: Array<{timestamp, value}>  or  Record<string, any>[]
        config: ChartConfig                    # title, unit, colors, etc
        theme: Ref<ThemeObject>                # Apply dark theme
      
      methods:
        // ECharts wrapper
        - onMounted: initialize echarts instance
        - watch data: update chart on data change
        - watch theme: re-render with new colors
        - handle resize: adapt to container size
      
      Line Chart (TimeSeriesChart.vue):
        - X-axis: time (auto-formatted dates)
        - Y-axis: metric value (with unit label)
        - Multiple series support (for comparison)
        - Hover tooltip with exact values
        - Click legend to toggle series
        - Zoom support (drag X-axis)
      
      Bar Chart (BarChart.vue):
        - X-axis: categories (services, error types, etc)
        - Y-axis: metric value
        - Color-coded by status or dimension
        - Hover to show exact values
        - Sort support
      
      Pie Chart (PieChart.vue):
        - Display proportion (e.g., error distribution)
        - Legend with clickable toggles
        - Animation on load
        - Label positioning (inside/outside)
      
      Heatmap (HeatmapChart.vue):
        - X-axis: time buckets (5min, 1hour, etc)
        - Y-axis: service/dimension
        - Color intensity: metric value
        - Hover to show exact value
        - Use case: 24h service activity view
      
      Flamegraph (FlameChart.vue):
        - Horizontal stacked rectangles
        - Width: span duration
        - Height: service layers
        - Color: by service or status
        - Click to zoom into span
        - Hover to show duration
      
      Gantt Chart (GanttChart.vue):
        - Timeline bars for concurrent spans
        - X-axis: time
        - Y-axis: span operation
        - Color: by status (green=success, red=error)
        - Shows parallelism clearly
      
      Topology Viewer (TopologyViewer.vue):
        - Use AntV G6 library
        - Nodes: services
        - Edges: call relationships
        - Edge labels: call count, latency
        - Interactive: pan, zoom, drag
        - Highlight on hover
        - Click node for details
    
    COMPONENT_SET_FILTERS:
      All filter components:
      
      props:
        value: any (current filter value)
        options: any[] (available filter values)
      
      emits:
        'change': (newValue) => void
      
      ServiceFilter (ServiceFilter.vue):
        - Multi-select dropdown
        - Search to filter options
        - Check/uncheck items
        - Show selected count
      
      EnvironmentFilter (EnvironmentFilter.vue):
        - Radio buttons or dropdown
        - Options: Production, Staging, Testing
        - Single or multi-select
      
      RegionFilter (RegionFilter.vue):
        - Hierarchical structure
        - Level 1: Region (us-east-1, eu-west-1, etc)
        - Level 2: Availability Zone (a, b, c)
        - Multi-select
      
      InstanceFilter (InstanceFilter.vue):
        - Text input with autocomplete
        - Dropdown suggestions as user types
        - Add multiple instances
      
      FilterBar (FilterBar.vue):
        - Combines all filters
        - Layout: horizontal filter list
        - Expand/collapse for space
        - Clear all button
        - Active filter count badge
    
    COMPONENT_SET_TIME_PICKER:
      TimeRangePicker (TimeRangePicker.vue):
        - Container component
        - Include: QuickTimeSelect, CustomDateTimeRange, RealtimeToggle
        - Bind to timeStore
      
      QuickTimeSelect (QuickTimeSelect.vue):
        - Buttons: 5m, 15m, 1h, 6h, 24h, 7d
        - Highlight selected preset
        - Click to apply
      
      CustomDateTimeRange (CustomDateTimeRange.vue):
        - Two sections: Start, End
        - Date picker for each
        - Time picker (HH:MM:SS)
        - Apply button
        - Validation: start < end
      
      RealtimeToggle (RealtimeToggle.vue):
        - Toggle switch (On/Off)
        - When on: show refresh interval selector
        - Options: 5s, 10s, 30s, 1min
        - Show "LIVE" indicator when active
        - Auto-advance time window
    
    COMPONENT_SET_LAYOUT:
      MainLayout (MainLayout.vue):
        - Two-column: sidebar (260px) + content
        - Sidebar contains navigation menu
        - Header above content area
        - Dark background colors
      
      Sidebar (Sidebar.vue):
        - Fixed left sidebar (260px wide)
        - Menu items: Dashboard, Metrics, Tracing, Logs, Custom
        - Icons + labels
        - Active indicator (highlight)
        - Collapsible sections (optional)
      
      Header (Header.vue):
        - Fixed top bar
        - Left: Page title/breadcrumb
        - Center: Time picker + filters
        - Right: Alert count, user menu
        - Sticky positioning
      
      Breadcrumbs (Breadcrumbs.vue):
        - Show navigation path
        - Dashboard > Service > Instance
        - Clickable to navigate back
      
      PageContent (PageContent.vue):
        - Scrollable main area
        - Padding/margins consistent
        - Responsive to window resize
    
    COMPONENT_SET_COMMON:
      LoadingSkeleton (LoadingSkeleton.vue):
        - Pulsing gray placeholder
        - Match content width/height
        - CSS animation
      
      EmptyState (EmptyState.vue):
        - Icon (from @iconify/vue)
        - Message: "No data available"
        - Action: helpful button (e.g., "Change filters")
      
      ErrorState (ErrorState.vue):
        - Error icon
        - Error message
        - Error code (if applicable)
        - Retry button
      
      ConfirmDialog (ConfirmDialog.vue):
        - Modal with title + message
        - Buttons: Cancel, Confirm
        - Icons and styling
    
    ================================================================================
    CORE LAYER 6: PAGE VIEWS
    ================================================================================
    
    VIEW_DASHBOARD:
      File: "src/views/Dashboard.vue"
      Purpose: "Main overview page with KPIs and alerts"
      
      Layout Sections:
        Row 1: Service health board (12 cols, 2 rows height)
        Row 2: Key metrics cards (12 cols, 4 cards in grid, 1 row height)
        Row 3: Alerts panel (6 cols), Trend charts (6 cols)
      
      Components Used:
        - HealthBoard (service status cards)
        - MetricCard (KPI cards: error rate, response time, QPS, resource util)
        - AlertPanel (active alerts with severity coloring)
        - LineChart (trend for key metrics)
      
      Data Flow:
        1. Load metrics from metricsStore
        2. Load alerts from alertsStore
        3. Bind to time range and filters
        4. Auto-refresh in real-time mode
      
      Interactions:
        - Click metric card → drill to Metrics page
        - Click alert → drill to related data (trace/log)
        - Change time range/filters → update all charts
    
    VIEW_METRICS:
      File: "src/views/Metrics.vue"
      Purpose: "Detailed metrics analysis per service"
      
      Layout:
        Left panel (3 cols): Service list
        Right panel (9 cols): Metric detail view
      
      Left Panel (ServiceList):
        - Searchable list of services
        - Click to select service
        - Show service status indicator
      
      Right Panel:
        - Tabs: Metrics, Comparison
        - Metrics tab: multiple charts (error rate, response time, QPS, CPU, memory, etc)
        - Chart type selector (line, bar, pie, heatmap)
        - Time range picker
        - Comparison tab: multi-service comparison view
      
      Components Used:
        - ServiceList (left panel)
        - LineChart, BarChart, PieChart (metric charts)
        - ChartContainer (with toolbar)
        - ComparisonView (multi-service)
      
      Data Binding:
        - When service selected: fetch that service's metrics
        - When time range changes: update all charts
        - Apply filters to metric data
    
    VIEW_TRACING:
      File: "src/views/Tracing.vue"
      Purpose: "Distributed trace visualization and analysis"
      
      Layout:
        Left panel (4 cols): Trace list
        Right panel (8 cols): Trace visualization (tabs)
      
      Left Panel (TraceList):
        - Search by trace ID
        - Filter by status (success/error)
        - Sort by duration, timestamp
        - Click to view trace detail
      
      Right Panel Tabs:
        - Topology: Service dependency graph (G6)
        - Flamechart: Trace execution timeline (horizontal rectangles)
        - Gantt: Span timeline with concurrency
        - Span list: Detailed span information
        - Slow queries: Detected performance issues
      
      Components Used:
        - TraceList (left panel)
        - TopologyViewer (service graph)
        - FlameChart (time series visualization)
        - GanttChart (concurrent timeline)
        - SpanDetail (expanded span info)
        - SlowQueryAnalysis
      
      Interactions:
        - Click service in topology → highlight related spans
        - Click span in flamechart → show detail
        - Click span with traceId → link to logs
        - Breadcrumb navigation
    
    VIEW_LOGS:
      File: "src/views/Logs.vue"
      Purpose: "Real-time log search and analysis"
      
      Layout:
        Top (2 rows): Search/filter bar
        Bottom: Log stream (with virtual scrolling)
        Right sidebar: Statistics
      
      Search/Filter Section:
        - Keyword input (regex support)
        - Field filters: service, level, traceId
        - Advanced query builder (optional)
        - Search history
        - Clear/reset button
      
      Log Stream:
        - Virtual scrolling (10,000+ items)
        - Color-coded by level
        - Click to expand and view full content
        - Click traceId → link to trace
        - Copy to clipboard button
      
      Statistics Sidebar:
        - Log count trend (line chart)
        - Level distribution (pie chart)
        - Top error messages
        - Export button
      
      Components Used:
        - LogSearch (search/filter UI)
        - LogStream (virtual scrolled list)
        - LogDetail (expanded log view)
        - LogStatistics (aggregated charts)
      
      Data Binding:
        - Search/filters trigger data fetch
        - Virtual scroll renders only visible items
        - Statistics update automatically
    
    VIEW_CUSTOM:
      File: "src/views/Custom.vue"
      Purpose: "User-configurable dashboard builder"
      
      Layout:
        Toolbar: Add chart, Apply template, Save, Load, Reset
        Main area: Drag-drop grid with widgets
      
      Features:
        - Drag widgets to reposition
        - Resize widgets with handles
        - Click on widget to configure
        - Configuration modal: data source, metric, chart type, thresholds
        - Templates: Application monitoring, Infrastructure, Business
        - Save/load dashboards to localStorage
        - Undo/redo support
      
      Grid System:
        - 12-column responsive grid
        - Min widget: 2x2 units
        - Max widget: 12x4 units
        - Auto-snap to grid
      
      Components Used:
        - DragDropGrid (main layout engine)
        - DashboardWidget (individual widget)
        - ChartConfig (configuration modal)
        - TemplateGallery (template selection)
        - DashboardManager (save/load/delete)
      
      Persistence:
        - Save to localStorage on every change (debounced 500ms)
        - Each dashboard is separate JSON object
        - Auto-recover from last session
    
    ================================================================================
    CORE LAYER 7: CROSS-MODULE LINKING
    ================================================================================
    
    LINKAGE_FLOW_METRIC_ANOMALY_TO_TRACE:
      User Action: Click on anomaly point in metric chart
      
      Step 1: Detect click event on anomalous data point
        - Point.value > threshold (e.g., P95 + 2*stdDev)
        - Extract time window around anomaly (±30 min)
      
      Step 2: Build navigation context
        - Service: from metric chart context
        - Time range: anomaly time ±30 min
        - Filters: apply to traces (optional)
      
      Step 3: Navigate and pre-filter
        - Router.push('/tracing', {
            params: { service, timeRange },
            query: { status: 'error|slow' }
          })
        - Pre-filter trace list to affected service + time
      
      Result: User sees traces that occurred during anomaly
    
    LINKAGE_FLOW_TRACE_TO_LOGS:
      User Action: Click on slow span in trace detail
      
      Step 1: Extract span context
        - Span ID, Trace ID, Service, Time range
      
      Step 2: Build log search query
        - Filter: traceId = span.traceId
        - Filter: service = span.service
        - Time range: span duration ±5 seconds
      
      Step 3: Navigate to Logs
        - Router.push('/logs', { query: {
            traceId: span.traceId,
            service: span.service,
            timeRange: {start, end}
          }})
      
      Result: User sees all logs from that span execution
    
    LINKAGE_FLOW_LOG_TO_TRACE:
      User Action: Click on traceId link in log entry
      
      Step 1: Extract traceId from log
        - log.traceId (if present)
      
      Step 2: Navigate to Tracing page
        - Router.push('/tracing', { query: { traceId } })
      
      Step 3: Display trace visualization
        - Fetch full trace from store
        - Highlight all spans in timeline
        - Show associated logs in context
      
      Result: User sees complete trace and related logs
    
    LINKAGE_IMPLEMENTATION:
      File: "src/router/index.ts"
      
      // Route definitions with query parameters
      routes: [
        {
          path: '/tracing',
          component: Tracing,
          beforeEnter: (to, from, next) => {
            // Apply query filters to trace list
            if (to.query.service) {
              filterStore.setFilter('service', [to.query.service])
            }
            if (to.query.traceId) {
              // Jump directly to trace detail
              traceStore.fetchTrace(to.query.traceId)
            }
            next()
          }
        }
      ]
      
      // Cross-module navigation helpers
      navigateToTrace(service: string, timeRange: DateRange) {
        router.push({
          name: 'tracing',
          query: {
            service,
            startTime: timeRange.start.toISOString(),
            endTime: timeRange.end.toISOString()
          }
        })
      }
      
      navigateToLogs(traceId: string, service: string) {
        router.push({
          name: 'logs',
          query: { traceId, service }
        })
      }
    
    ================================================================================
    CORE LAYER 8: DATA PROCESSING PIPELINES
    ================================================================================
    
    PIPELINE_METRIC_RETRIEVAL:
      Entry: User selects metric + time range
      
      Step 1: Calculate aggregation level
        if (timeRange > 24h) {
          aggregationBucket = 1h
        } else if (timeRange > 6h) {
          aggregationBucket = 30min
        } else {
          aggregationBucket = 1min
        }
      
      Step 2: Generate/retrieve mock data
        rawData = generateTimeSeries({
          baseValue: config.baseValue,
          amplitude: config.amplitude,
          interval: aggregationBucket,
          startTime: timeRange.start,
          endTime: timeRange.end
        })
      
      Step 3: Apply filters
        filtered = filterData(rawData, activeFilters, filterRules)
      
      Step 4: Aggregate if needed
        if (rawData.length > 1000) {
          aggregated = aggregateTimeSeries(rawData, maxPoints=500)
        } else {
          aggregated = rawData
        }
      
      Step 5: Transform to chart format
        chartData = {
          xAxis: aggregated.map(p => p.timestamp),
          series: [{
            name: metricName,
            data: aggregated.map(p => p.value)
          }]
        }
      
      Step 6: Return reactive data
        metricsStore.setMetrics(metricId, chartData)
        // Components reactively update
    
    PIPELINE_TRACE_RETRIEVAL:
      Entry: User navigates to Tracing page
      
      Step 1: Fetch trace list
        traces = tracesStore.fetchTraces({
          service: filters.service,
          timeRange: timeStore.range,
          status: filters.status
        })
      
      Step 2: Detect slow spans
        slowSpans = detectSlowSpans(trace.spans)
        mark slowSpans with red coloring
      
      Step 3: Build topology graph
        nodes = extractUniqueServices(traces)
        edges = extractCallRelationships(traces)
        graph = buildDAG(nodes, edges)
      
      Step 4: Display trace list
        renderTraceList(traces, { sortBy: 'duration' })
      
      Step 5: On trace selection
        selectedTrace = traces.find(t => t.id === traceId)
        renderFlameChart(selectedTrace.spans)
        renderGanttChart(selectedTrace.spans)
        renderSpanDetail(selectedTrace)
    
    PIPELINE_LOG_SEARCH:
      Entry: User enters search query
      
      Step 1: Parse query
        parsed = parseQuery(searchInput)
        // Extract: keywords, field filters, operators
        // Result: { keywords: ['error'], fields: {level: ['ERROR']}, ...}
      
      Step 2: Apply search to all logs
        matches = logService.search(parsed, filters)
        // Keyword matching (regex if needed)
        // Field filtering (exact match)
      
      Step 3: Apply global filters
        filtered = matches.filter(log => {
          return Object.entries(filters).every(([type, values]) => {
            const rule = filterRules[type]
            return values.some(v => rule(log, v))
          })
        })
      
      Step 4: Highlight matches
        highlightedLogs = highlightMatches(filtered, searchInput)
      
      Step 5: Return paginated results
        results = paginate(highlightedLogs, pageSize=50)
        return { results, totalCount, pageCount }
      
      Step 6: Render with virtual scrolling
        <VirtualScroller
          :items="results"
          :renders="50 items at a time"
        />
        // Can handle 10,000+ items smoothly
    
    ================================================================================
    PERFORMANCE OPTIMIZATIONS (Critical)
    ================================================================================
    
    OPTIMIZATION_VIRTUAL_SCROLLING:
      Location: Log stream view
      Library: vue-virtual-scroller
      Benefit: Render 10,000+ items without lag
      
      Implementation:
        <DynamicScroller
          :items="logs"
          :item-size="48"
          key-field="id"
        >
          <template #default="{ item }">
            <LogEntry :log="item" />
          </template>
        </DynamicScroller>
      
      Performance Impact:
        - Without: Initial render 3000ms, scroll lag
        - With: Initial render 50ms, smooth scroll
        - Memory: ~5MB for 10k visible + buffer (vs 100MB for all)
    
    OPTIMIZATION_LAZY_LOADING_CHARTS:
      Location: Dashboard with 15-20 charts
      Method: Intersection Observer API
      Benefit: Only render visible charts
      
      Implementation:
        const isVisible = ref(false)
        const chartRef = ref(null)
        
        onMounted(() => {
          const observer = new IntersectionObserver(([entry]) => {
            isVisible.value = entry.isIntersecting
          })
          observer.observe(chartRef.value)
        })
        
        watch(isVisible, (newVal) => {
          if (newVal) {
            initializeChart()  // Only when visible
          }
        })
      
      Performance Impact:
        - Dashboard load: 3s → 1.5s
        - Time to interactive: 5s → 2s
    
    OPTIMIZATION_DATA_AGGREGATION:
      Location: Time series data with >1000 points
      Method: Largest-Triangle-Three-Buckets (LTTB)
      Benefit: Preserve visual patterns while reducing points
      
      Implementation:
        function aggregateTimeSeries(points, maxPoints) {
          if (points.length <= maxPoints) return points
          
          const bucketSize = Math.ceil(points.length / maxPoints)
          const aggregated = []
          
          for (let i = 0; i < points.length; i += bucketSize) {
            const bucket = points.slice(i, i + bucketSize)
            const avgValue = avg(bucket.map(p => p.value))
            const maxValue = Math.max(...bucket.map(p => p.value))
            const minValue = Math.min(...bucket.map(p => p.value))
            
            aggregated.push({
              timestamp: bucket[0].timestamp,
              value: avgValue,
              max: maxValue,
              min: minValue
            })
          }
          
          return aggregated
        }
      
      Performance Impact:
        - Chart render: 1000 points (500ms) → 500 points (200ms)
        - Visual quality: Minimal loss, preserves spikes
    
    OPTIMIZATION_LOCALSTORAGE_CACHING:
      Items Cached:
        - Dashboard configurations (24h TTL)
        - Filter presets (persistent)
        - User preferences (persistent)
        - Time range session (session TTL)
      
      Implementation:
        class StorageService {
          static KEYS = {
            DASHBOARDS: 'monitoring_dashboards',
            FILTERS: 'monitoring_filters_presets',
            THEME: 'monitoring_theme'
          }
          
          static saveDashboard(id, config) {
            const key = `${this.KEYS.DASHBOARDS}_${id}`
            localStorage.setItem(key, JSON.stringify({
              config,
              timestamp: Date.now()
            }))
          }
          
          static loadDashboard(id) {
            const key = `${this.KEYS.DASHBOARDS}_${id}`
            const data = localStorage.getItem(key)
            if (!data) return null
            
            const { config, timestamp } = JSON.parse(data)
            if (Date.now() - timestamp > 24 * 60 * 60 * 1000) {
              localStorage.removeItem(key)  // Expired
              return null
            }
            
            return config
          }
        }
      
      Performance Impact:
        - First load: Fetch from API (1s)
        - Subsequent loads: From cache (10ms)
    
    OPTIMIZATION_ECHARTS_SETTINGS:
      For each chart instance:
        option = {
          animation: true,
          animationDuration: 500,
          animationEasing: 'cubicOut',
          sampling: 'lttb',  // Enable for >2000 points
          silent: false,     // Disable during heavy interaction
          hoverLayerThreshold: 1000  // Don't group if too many items
        }
      
      Large Mode for Desktop:
        option = {
          ...option,
          large: true,  // GPU-accelerated rendering
          largeThreshold: 2000  // Threshold for large mode
        }
    
    TARGET_PERFORMANCE_METRICS:
      First Contentful Paint: < 2000ms
      Time to Interactive: < 2000ms
      Page Transition: < 300ms
      Single Chart Render: < 500ms
      Data Refresh (Real-time): < 200ms
      Virtual Scroll (10k items): Smooth, no jank
      Memory Usage: < 150MB for full 24h dataset
  
  ============================================================================
  SECTION 3: VALIDATION & EVALUATION APPROACH
  ============================================================================

  validation_approach: |
    
    ================================================================================
    FUNCTIONAL TESTING REQUIREMENTS
    ================================================================================
    
    TEST_CATEGORY_DASHBOARD_MODULE:
      Test: Service health board displays all services
        Steps:
          1. Load Dashboard page
          2. Verify health board shows 3 services
          3. Check status indicators (healthy/warning/critical)
          4. Verify colors match design (green/yellow/red)
        Expected: All services visible with correct status colors
        Success Criteria: 100% of services displayed
      
      Test: Key metrics overview shows correct values
        Steps:
          1. Load Dashboard
          2. Verify KPI cards: error rate, response time, QPS, resource util
          3. Check values are numeric with units
          4. Verify trend arrows (up/down) are present
        Expected: All KPI cards visible with valid data
        Success Criteria: 4 KPI cards + trend indicators
      
      Test: Alert panel displays alerts sorted by severity
        Steps:
          1. Load Dashboard
          2. Verify alert list appears
          3. Check sorting: critical > warning > info
          4. Verify alert count badge matches list
        Expected: Alerts sorted by severity
        Success Criteria: Alerts in correct order
      
      Test: Trend charts render with configurable time range
        Steps:
          1. Load Dashboard
          2. Change time preset (1h → 6h)
          3. Verify charts update
          4. Check line patterns adjust correctly
        Expected: Charts update immediately
        Success Criteria: Charts responsive to time change
      
      Test: Real-time mode auto-refreshes data
        Steps:
          1. Enable real-time mode
          2. Set refresh interval to 5 seconds
          3. Observe data updates
          4. Disable real-time mode
        Expected: Data updates every 5 seconds
        Success Criteria: Data changes visible at 5s intervals
    
    TEST_CATEGORY_METRICS_MODULE:
      Test: Service list displays all services
        Steps:
          1. Navigate to Metrics page
          2. Verify service list appears on left
          3. Check all 3 services visible
          4. Search by service name
        Expected: Service list fully functional
        Success Criteria: All services searchable
      
      Test: Business metrics display correctly
        Steps:
          1. Select service from list
          2. Verify error rate, success rate, QPS, response times appear
          3. Check P50, P90, P99 percentiles
          4. Verify units are correct (%, ms, req/s)
        Expected: All business metrics visible
        Success Criteria: 6+ metrics displayed per service
      
      Test: System metrics display correctly
        Steps:
          1. Scroll down metric list
          2. Verify CPU, memory, disk I/O, network bandwidth appear
          3. Check values are reasonable (0-100% for CPU/memory)
          4. Verify time series charts render
        Expected: System metrics fully displayed
        Success Criteria: 4 system metric charts
      
      Test: Chart type switching works
        Steps:
          1. Display metric in line chart (default)
          2. Switch to bar chart
          3. Switch to pie chart (if applicable)
          4. Switch to heatmap
        Expected: Charts switch without errors
        Success Criteria: All chart types render correctly
      
      Test: Multi-service comparison
        Steps:
          1. Select 2-3 services for comparison
          2. Verify comparison view shows metrics side-by-side
          3. Check difference calculation
          4. Verify percentage change displayed
        Expected: Comparison view functional
        Success Criteria: Differences highlighted correctly
    
    TEST_CATEGORY_TRACING_MODULE:
      Test: Trace list displays with correct columns
        Steps:
          1. Navigate to Tracing page
          2. Verify columns: TraceID, Service, Duration, Status
          3. Check data is populated
          4. Verify sorting works
        Expected: Trace list fully functional
        Success Criteria: All columns visible + sortable
      
      Test: Trace search by ID works
        Steps:
          1. Enter trace ID in search box
          2. Verify search results appear
          3. Try non-existent trace ID
          4. Verify empty state or no results
        Expected: Search functional
        Success Criteria: Correct traces found
      
      Test: Topology map visualizes services
        Steps:
          1. Load Tracing page
          2. Verify service dependency graph appears
          3. Check nodes represent services
          4. Check edges show call relationships
          5. Verify interactive pan/zoom works
        Expected: Topology map fully functional
        Success Criteria: Services connected with call relationships
      
      Test: Flamechart shows span timeline
        Steps:
          1. Select trace from list
          2. Click flamechart tab
          3. Verify horizontal rectangles (spans)
          4. Check duration proportional to width
          5. Verify colors indicate status (green/red)
        Expected: Flamechart displays correctly
        Success Criteria: Spans visible with correct proportions
      
      Test: Gantt chart shows concurrent spans
        Steps:
          1. Select trace
          2. Click gantt chart tab
          3. Verify timeline bars for each span
          4. Check concurrent spans stacked horizontally
          5. Verify time axis is readable
        Expected: Gantt chart shows concurrency
        Success Criteria: Parallel spans visible
      
      Test: Span detail shows all information
        Steps:
          1. Select trace
          2. Click on span to expand
          3. Verify span details: ID, service, operation, duration
          4. Check tags and logs displayed
        Expected: Span detail complete
        Success Criteria: All span info visible
      
      Test: Slow query detection highlights bottlenecks
        Steps:
          1. Open trace with varying span durations
          2. Verify longest spans highlighted (red)
          3. Check slow query analysis section
          4. Verify sorted by duration
        Expected: Slow queries identified and highlighted
        Success Criteria: Bottlenecks clearly marked
    
    TEST_CATEGORY_LOGS_MODULE:
      Test: Log stream renders with virtual scrolling
        Steps:
          1. Navigate to Logs page
          2. Verify log entries appear
          3. Scroll through 10,000+ items
          4. Check performance (no lag)
        Expected: Virtual scrolling working
        Success Criteria: Smooth scroll, no stutter
      
      Test: Keyword search works with regex
        Steps:
          1. Enter keyword: "error"
          2. Verify logs containing "error" appear
          3. Try regex pattern: "error|fail"
          4. Check case sensitivity toggle
        Expected: Search functional
        Success Criteria: Correct logs matched
      
      Test: Field filtering works
        Steps:
          1. Filter by service: select "api-service"
          2. Verify only logs from api-service appear
          3. Filter by level: select "ERROR"
          4. Verify only error logs shown
          5. Combine filters (service AND level)
        Expected: Filters work correctly
        Success Criteria: Data correctly filtered
      
      Test: Log level filtering shows correct distribution
        Steps:
          1. Verify default shows all levels
          2. Filter to ERROR only
          3. Verify count matches statistics
          4. Try multiple level selection
        Expected: Level filtering accurate
        Success Criteria: Correct logs shown per level
      
      Test: Log detail view shows full content
        Steps:
          1. Click on log entry to expand
          2. Verify full message displayed
          3. Check context logs (prev/next N lines)
          4. Verify traceId link (if present)
        Expected: Full log context visible
        Success Criteria: Related logs shown
      
      Test: Log statistics display correctly
        Steps:
          1. Verify log count trend chart appears
          2. Check level distribution pie chart
          3. Verify statistics match log stream
          4. Change time range and verify stats update
        Expected: Statistics accurate
        Success Criteria: Charts match underlying data
    
    TEST_CATEGORY_CUSTOM_DASHBOARD:
      Test: Drag-drop layout works
        Steps:
          1. Navigate to Custom Dashboard
          2. Drag chart to new position
          3. Verify grid snapping
          4. Drop and verify position saved
        Expected: Drag-drop functional
        Success Criteria: Smooth movement, correct snapping
      
      Test: Widget resizing works
        Steps:
          1. Hover over widget corner (resize handle)
          2. Drag to resize larger
          3. Verify grid respects bounds
          4. Check chart resizes responsively
        Expected: Resizing functional
        Success Criteria: Charts adapt to new size
      
      Test: Chart configuration modal
        Steps:
          1. Click "Add Chart" button
          2. Verify configuration modal appears
          3. Select data source (metric)
          4. Select chart type (line, bar, pie)
          5. Click "Add"
        Expected: Chart added to dashboard
        Success Criteria: New widget appears
      
      Test: Dashboard templates
        Steps:
          1. Click "Apply Template"
          2. Select "Application Monitoring"
          3. Verify template charts added
          4. Check chart configurations match template
        Expected: Template applied successfully
        Success Criteria: All template charts present
      
      Test: Save/load dashboards
        Steps:
          1. Create custom dashboard layout
          2. Click "Save" button
          3. Enter dashboard name
          4. Reload page
          5. Click "Load" and select saved dashboard
          6. Verify layout restored exactly
        Expected: Dashboard persisted
        Success Criteria: Configuration survives reload
    
    TEST_CATEGORY_INTERACTIONS:
      Test: Time range selector applies to all modules
        Steps:
          1. Change time range to 6h
          2. Navigate to Metrics
          3. Verify charts show 6h of data
          4. Navigate to Logs
          5. Verify logs filtered to last 6h
        Expected: Time range propagates
        Success Criteria: All modules respect time range
      
      Test: Filter persistence across modules
        Steps:
          1. Set filter: service = "api-service"
          2. Navigate to Metrics
          3. Verify only api-service data shown
          4. Navigate to Tracing
          5. Verify only api-service traces shown
        Expected: Filters apply everywhere
        Success Criteria: Data correctly filtered
      
      Test: Real-time mode functionality
        Steps:
          1. Enable real-time mode
          2. Set refresh interval 5s
          3. Observe data updates
          4. Disable real-time mode
          5. Verify updates stop
        Expected: Real-time working
        Success Criteria: Auto-refresh at set interval
      
      Test: Time comparison works
        Steps:
          1. Enable "Compare with Previous Period"
          2. Verify two lines on same chart
          3. Check legend shows "Current" and "Previous"
          4. Verify visual distinction (solid vs dashed)
        Expected: Comparison displayed
        Success Criteria: Two series clearly distinguished
    
    TEST_CATEGORY_CROSS_MODULE_LINKING:
      Test: Metric anomaly links to traces
        Steps:
          1. Dashboard shows error rate spike
          2. Click on anomalous data point
          3. Navigate to Tracing page
          4. Verify traces filtered to same time window
          5. Check traces from affected service shown
        Expected: Navigation + filtering works
        Success Criteria: Relevant traces visible
      
      Test: Trace links to logs
        Steps:
          1. Open trace detail
          2. Click on span
          3. Click "View Logs" button
          4. Navigate to Logs page
          5. Verify logs filtered by traceId
        Expected: Log search pre-filtered
        Success Criteria: Only matching logs shown
      
      Test: Log links to trace
        Steps:
          1. Find log entry with traceId
          2. Click traceId link
          3. Navigate to Tracing page
          4. Verify specific trace loaded
          5. Check all spans displayed
        Expected: Trace visualization
        Success Criteria: Full trace shown
      
      Test: Breadcrumb navigation
        Steps:
          1. Start at Dashboard
          2. Click metric → Metrics page
          3. Select service → metric detail
          4. Click "View Trace" → Tracing page
          5. Click breadcrumb "Metrics"
          6. Verify return to metrics detail
        Expected: Navigation history preserved
        Success Criteria: Back navigation works
    
    TEST_CATEGORY_ALERT_MANAGEMENT:
      Test: Alert rules display
        Steps:
          1. Navigate to Alerts section
          2. Verify alert rules listed
          3. Check rule name, condition, threshold
          4. Verify enabled/disabled toggle works
        Expected: Rules fully visible
        Success Criteria: All rules displayed + toggleable
      
      Test: Alert history with filtering
        Steps:
          1. View alert history
          2. Filter by time range
          3. Filter by severity
          4. Verify alert list updates
          5. Sort by triggered time
        Expected: History filtering works
        Success Criteria: Correct alerts shown
      
      Test: Alert detail shows context
        Steps:
          1. Click alert in history
          2. Verify detail modal appears
          3. Check trigger condition displayed
          4. Verify affected services listed
          5. Check recovery time shown
        Expected: Detail complete
        Success Criteria: All context visible
    
    ================================================================================
    PERFORMANCE VALIDATION
    ================================================================================
    
    PERFORMANCE_TEST_FIRST_CONTENTFUL_PAINT:
      Test: First screen loads in < 2 seconds
      Measurement: performance.timing.domContentLoaded
      Steps:
        1. Clear browser cache
        2. Open application
        3. Measure load time with Chrome DevTools
        4. Repeat 3 times
      Expected: < 2000ms average
      Success Criteria: All 3 runs < 2s
    
    PERFORMANCE_TEST_PAGE_TRANSITION:
      Test: Route changes complete in < 300ms
      Measurement: time from route.beforeEach to component mounted
      Steps:
        1. Dashboard page loaded
        2. Click Metrics link
        3. Measure render time
        4. Repeat for all route transitions
      Expected: < 300ms
      Success Criteria: All transitions < 300ms
    
    PERFORMANCE_TEST_CHART_RENDERING:
      Test: Single chart renders in < 500ms
      Measurement: ECharts init + setOption time
      Steps:
        1. Navigate to Metrics page
        2. Measure time to display first chart
        3. Repeat for different chart types
      Expected: < 500ms
      Success Criteria: All chart types < 500ms
    
    PERFORMANCE_TEST_DATA_REFRESH:
      Test: Real-time data updates in < 200ms
      Measurement: time from data fetch to DOM update
      Steps:
        1. Enable real-time mode
        2. Set refresh interval 10s
        3. Measure update time each cycle
        4. Average over 10 cycles
      Expected: < 200ms average
      Success Criteria: Refresh cycle < 200ms
    
    PERFORMANCE_TEST_VIRTUAL_SCROLLING:
      Test: 10,000 log items scroll smoothly
      Measurement: FPS during scroll, frame time
      Steps:
        1. Navigate to Logs
        2. Generate 10,000 log entries
        3. Scroll through list
        4. Measure FPS with Chrome DevTools
      Expected: 60 FPS (no jank)
      Success Criteria: Sustained 50+ FPS during scroll
    
    PERFORMANCE_TEST_MEMORY_USAGE:
      Test: Memory usage < 150MB with 24h data
      Measurement: Chrome DevTools Memory tab
      Steps:
        1. Load app with full 24h dataset
        2. Open 15-20 charts simultaneously
        3. Measure heap size
      Expected: < 150MB
      Success Criteria: Memory stable, no growth after load
    
    PERFORMANCE_TEST_AGGREGATION:
      Test: Automatic aggregation preserves patterns
      Measurement: Visual comparison + statistical correlation
      Steps:
        1. Generate 10,000-point series
        2. Aggregate to 500 points (LTTB algorithm)
        3. Compare visualizations
        4. Calculate correlation coefficient
      Expected: > 0.95 correlation, spikes preserved
      Success Criteria: Patterns match, peaks visible
    
    ================================================================================
    MOCK DATA QUALITY VALIDATION
    ================================================================================
    
    VALIDATION_DATA_QUALITY_METRICS:
      Test: Metric data realistic patterns
        Steps:
          1. Generate 7 days of CPU usage data
          2. Plot time series
          3. Verify sine wave oscillation (hourly/daily)
          4. Verify random noise (10-20% variation)
          5. Check bounds (0-100%)
        Expected: Natural-looking curves
        Success Criteria: Visual inspection passes
      
      Test: Response time percentiles correct
        Steps:
          1. Generate 1000 response times
          2. Calculate P50, P90, P99
          3. Verify P50 < P90 < P99
          4. Check realistic ratios (P99 ≈ 3-5x P50)
        Expected: Correct ordering + realistic ratios
        Success Criteria: Percentiles monotonically increase
      
      Test: Error rate realistic distribution
        Steps:
          1. Generate 10,000 logs over 24h
          2. Count errors per hour
          3. Verify average ~0.5%
          4. Verify occasional spikes (error clusters)
          5. Check error distribution (80% daytime)
        Expected: Realistic error patterns
        Success Criteria: Error rate within expected range
    
    VALIDATION_DATA_QUALITY_TRACES:
      Test: Trace call chains realistic
        Steps:
          1. Generate 100 traces
          2. Verify all have 3-10 spans
          3. Check parent-child relationships valid
          4. Verify no circular dependencies
          5. Check ~95% success rate (5% error)
        Expected: Valid trace structures
        Success Criteria: All traces pass validation
      
      Test: Span latencies realistic
        Steps:
          1. Check span durations follow exponential distribution
          2. Verify most < 100ms
          3. Verify few > 500ms
          4. Check slow spans marked
        Expected: Latencies realistic
        Success Criteria: Distribution matches reality
      
      Test: Service dependencies consistent
        Steps:
          1. Extract all service pairs from traces
          2. Verify no impossible dependencies
          3. Check services called reflect pool
          4. Verify no self-calling services
        Expected: Consistent call graph
        Success Criteria: No invalid dependencies
    
    VALIDATION_DATA_QUALITY_LOGS:
      Test: Log level distribution correct
        Steps:
          1. Generate 100,000 logs
          2. Count by level: DEBUG, INFO, WARN, ERROR, FATAL
          3. Verify distribution: 10%, 50%, 25%, 14%, 1%
          4. Check clusters of errors
        Expected: Distribution matches config
        Success Criteria: Within ±5% of expected
      
      Test: Log timestamps realistic
        Steps:
          1. Generate 24h of logs
          2. Check timestamps monotonically increase
          3. Verify density varies by time (business vs off-hours)
          4. Check for realistic gaps
        Expected: Natural temporal distribution
        Success Criteria: Timestamp validation passes
      
      Test: Log messages realistic
        Steps:
          1. Sample 100 random logs
          2. Manual inspection of messages
          3. Verify messages appropriate for level
          4. Check no obviously fake or nonsensical messages
        Expected: Realistic log content
        Success Criteria: Messages read naturally
    
    ================================================================================
    VISUAL & UX VALIDATION
    ================================================================================
    
    VISUAL_TEST_DARK_THEME:
      Test: Dark theme applied consistently
        Steps:
          1. Load all pages
          2. Check backgrounds are dark (#0b0c0e, #181b1f)
          3. Verify text is light (#d8d9da)
          4. Check contrast ratios WCAG AA
          5. Verify no bright white backgrounds
        Expected: Consistent dark theme
        Success Criteria: All elements themed
    
    VISUAL_TEST_COLOR_SCHEME:
      Test: Status colors used correctly
        Steps:
          1. Verify healthy services: green (#73bf69)
          2. Verify warnings: orange (#ff9830)
          3. Verify errors: red (#f2495c)
          4. Verify information: blue (#3274d9)
        Expected: Consistent color coding
        Success Criteria: Colors match design spec
    
    VISUAL_TEST_TYPOGRAPHY:
      Test: Font sizes readable at 1920x1080
        Steps:
          1. Open at 1920x1080
          2. Read all text without squinting
          3. Check headers are prominent
          4. Verify labels are clear
        Expected: Readable text
        Success Criteria: No text too small
    
    VISUAL_TEST_SPACING:
      Test: Padding and margins consistent
        Steps:
          1. Measure card padding (16px expected)
          2. Check section spacing (24px expected)
          3. Verify grid gaps uniform
          4. Check no awkward spacing
        Expected: Consistent spacing grid
        Success Criteria: Spacing follows 8px system
    
    VISUAL_TEST_RESPONSIVE:
      Test: Layout responsive to container size
        Steps:
          1. Test at 1920x1080 (primary)
          2. Test at 2560x1440 (secondary)
          3. Test at smaller widths (1600x900)
          4. Verify no horizontal scrollbars
          5. Check readability at all sizes
        Expected: Scales appropriately
        Success Criteria: No layout breaks
    
    VISUAL_TEST_ANIMATIONS:
      Test: Animations smooth and professional
        Steps:
          1. Watch chart loading animation
          2. Observe page transition animation
          3. Check hover state transitions (300ms)
          4. Verify no jarring movements
          5. Check animation consistency
        Expected: Smooth 300-500ms animations
        Success Criteria: All animations fluid
    
    UX_TEST_NAVIGATION:
      Test: Navigation intuitive
        Steps:
          1. New user tries to navigate
          2. Can find each module without help
          3. Breadcrumbs clear
          4. Back button works
          5. No dead ends
        Expected: Navigation obvious
        Success Criteria: User can explore freely
    
    UX_TEST_DISCOVERABILITY:
      Test: Features are discoverable
        Steps:
          1. Can find time range selector
          2. Can find filters
          3. Can find alert panel
          4. Can find search functions
          5. Can find export/save options
        Expected: All features accessible
        Success Criteria: No hidden features
    
    ================================================================================
    EXPECTED RESULTS & SUCCESS CRITERIA
    ================================================================================
    
    SUCCESS_DASHBOARD_MODULE:
      ✓ Service health board shows 3 services with correct status
      ✓ 4 KPI cards display with valid metrics + trend arrows
      ✓ Alert panel shows 5-10 active alerts sorted by severity
      ✓ 4 trend charts render with configurable time range
      ✓ Real-time mode updates every 10 seconds
      ✓ All data refreshes < 200ms
      ✓ No console errors or warnings
    
    SUCCESS_METRICS_MODULE:
      ✓ Service list displays all 3 services
      ✓ Business metrics: error rate, success rate, QPS, P50/P90/P99
      ✓ System metrics: CPU, memory, disk I/O, network
      ✓ 4 chart types switch smoothly (line, bar, pie, heatmap)
      ✓ Comparison view shows side-by-side metrics
      ✓ All charts render < 500ms
    
    SUCCESS_TRACING_MODULE:
      ✓ Trace list displays 100+ traces with columns
      ✓ Trace search by ID works
      ✓ Topology graph shows service dependencies
      ✓ Flamechart shows span timeline correctly
      ✓ Gantt chart shows concurrent spans
      ✓ Span details fully visible
      ✓ Slow queries highlighted and sorted
    
    SUCCESS_LOGS_MODULE:
      ✓ Virtual scrolling renders 10,000+ logs smoothly
      ✓ Keyword search works with regex
      ✓ Field filtering (service, level, traceId) accurate
      ✓ Log detail view shows full context
      ✓ Statistics charts match underlying data
      ✓ Scroll performance: 60 FPS sustained
    
    SUCCESS_CUSTOM_DASHBOARD:
      ✓ Drag-drop works smoothly with grid snapping
      ✓ Widget resizing works, charts adapt
      ✓ Chart configuration modal functional
      ✓ Templates apply correctly
      ✓ Save/load persists across reloads
      ✓ Undo/redo works
    
    SUCCESS_PERFORMANCE:
      ✓ First load < 2 seconds
      ✓ Page transitions < 300ms
      ✓ Chart render < 500ms
      ✓ Real-time refresh < 200ms
      ✓ Virtual scroll smooth (50+ FPS)
      ✓ Memory < 150MB
    
    SUCCESS_MOCK_DATA:
      ✓ Time series realistic patterns (sine + noise)
      ✓ Traces valid with realistic latencies
      ✓ Logs realistic distribution by time + level
      ✓ Error clustering visible
      ✓ TraceID correlation correct
    
    SUCCESS_VISUAL:
      ✓ Dark theme consistent throughout
      ✓ Color scheme matches design
      ✓ Typography readable
      ✓ Spacing consistent
      ✓ Responsive at 1920x1080 and 2560x1440
      ✓ Animations smooth 300-500ms
    
    SUCCESS_CROSS_MODULE:
      ✓ Metric anomaly → Trace navigation works
      ✓ Trace → Log navigation works
      ✓ Log → Trace navigation works
      ✓ Breadcrumb navigation functional
      ✓ Filter state preserved across modules
      ✓ Time range propagates everywhere
    
    OVERALL_SUCCESS_CRITERIA:
      ✓ All functional tests pass (100%)
      ✓ All performance targets met
      ✓ All visual checks pass
      ✓ No critical bugs or errors
      ✓ Smooth user experience
      ✓ Professional monitoring platform appearance
      ✓ Ready for production demonstration

  ============================================================================
  SECTION 4: ENVIRONMENT SETUP
  ============================================================================

  environment_setup: |
    
    SYSTEM_REQUIREMENTS:
      Node.js: ≥ 18.0.0 (LTS recommended)
      npm: ≥ 9.0.0
      Browser: Chrome 90+, Firefox 88+, Edge 90+
      Display: 1920x1080 minimum (primary), 2560x1440 secondary
      Memory: 4GB RAM minimum
      Storage: 500MB for development environment
    
    INSTALLATION_STEPS:
      Step 1: Clone repository
        git clone <repository-url>
        cd observability-monitoring-platform
      
      Step 2: Install dependencies
        npm install
      
      Step 3: Install specific versions (critical dependencies)
        npm install vue@3.3.4
        npm install vite@4.4.0
        npm install typescript@5.1.6
        npm install pinia@2.1.3
        npm install element-plus@2.4.0
        npm install echarts@5.4.2
        npm install @antv/g6@5.0.0
        npm install vue-virtual-scroller@1.0.10
        npm install sass@1.66.1
        npm install @iconify/vue@4.1.1
        npm install gsap@3.12.2
        npm install dayjs@1.11.10
        npm install uuid@9.0.0
        npm install mockjs@1.1.0
      
      Step 4: Development tools
        npm install --save-dev @vue/test-utils@2.4.1
        npm install --save-dev vitest@0.34.0
        npm install --save-dev eslint@8.49.0
        npm install --save-dev eslint-plugin-vue@9.17.0
        npm install --save-dev prettier@3.0.2
        npm install --save-dev @types/node@20.5.1
    
    PROJECT_STRUCTURE_VERIFICATION:
      After installation, verify:
        ✓ node_modules/ directory created
        ✓ package.json has all dependencies
        ✓ package-lock.json generated
        ✓ .env.example present
        ✓ All source files under src/
    
    DEVELOPMENT_SERVER_STARTUP:
      Command: npm run dev
      Expected Output:
        > vite
        ➜ Local:   http://localhost:5173/
        ➜ press h to show help
      
      Access: Open http://localhost:5173/ in browser
      Expected: Dashboard page loads with data
    
    BUILD_PRODUCTION:
      Command: npm run build
      Output: dist/ directory created
      Expected Size: < 1MB gzipped
      Next: npm run preview (test production build locally)
    
    CONFIGURATION_FILES:
      vite.config.ts:
        - Define: server port (5173)
        - Define: build output directory (dist/)
        - Define: alias paths (@/ → src/)
        - Enable: HMR for development
      
      tsconfig.json:
        - compilerOptions.strict: true
        - compilerOptions.moduleResolution: bundler
        - compilerOptions.lib: ["ES2020", "DOM", "DOM.Iterable"]
        - include: ["src/**/*.ts", "src/**/*.vue"]
      
      .eslintrc.cjs:
        - Parser: @vue/eslint-parser
        - Rules: no-unused-vars, quotes, semi, etc
        - Vue specific rules enabled
      
      .prettierrc.json:
        - printWidth: 100
        - tabWidth: 2
        - trailingComma: es5
        - semi: true
        - singleQuote: true
    
    ENVIRONMENT_VARIABLES:
      Create .env.local file:
        VITE_APP_TITLE=Observability Monitoring Platform
        VITE_API_TIMEOUT=5000
        VITE_MOCK_DATA_ENABLED=true
        VITE_LOG_LEVEL=info
        VITE_THEME=dark
    
    MOCK_DATA_INITIALIZATION:
      Auto-initialization on app startup:
        1. src/main.ts imports src/mock/index.ts
        2. generateMockData() creates 24h dataset
        3. Data stored in Pinia stores
        4. Ready for component consumption
      
      Data generation time: ~500ms (acceptable)
      Generated data size: ~50MB (in-memory, acceptable)
    
    PRE_DEVELOPMENT_CHECKLIST:
      ✓ Node.js version 18+ verified (node --version)
      ✓ npm version 9+ verified (npm --version)
      ✓ npm install completed successfully
      ✓ Development server starts (npm run dev)
      ✓ No console errors on initial load
      ✓ Dashboard page displays with mock data
      ✓ ESLint configured and working
      ✓ TypeScript strict mode enabled
      ✓ Browser DevTools accessible
    
    BROWSER_DEVELOPER_TOOLS_SETUP:
      Vue DevTools Extension:
        - Install "Vue.js devtools" from browser extension store
        - Enable in Chrome: chrome://extensions/
        - Use to inspect component hierarchy
        - Inspect Pinia stores in real-time
      
      Chrome DevTools:
        - F12 to open
        - Console tab: check for errors
        - Network tab: monitor data fetching
        - Performance tab: profile rendering
        - Memory tab: track heap usage
      
      Performance Profiling:
        - Record performance trace
        - Identify slow renders
        - Analyze frame time > 16ms
        - Check CPU throttling impact
    
    DEBUGGING_COMMON_ISSUES:
      Issue: Port 5173 already in use
        Solution: npm run dev -- --port 5174
      
      Issue: Mock data not generating
        Solution: Check src/mock/index.ts isExecuted on app mount
      
      Issue: ECharts not rendering
        Solution: Verify theme is set via useChartTheme()
      
      Issue: Pinia stores not reactive
        Solution: Ensure stores returned from defineStore() correctly
      
      Issue: Virtual scroll lag
        Solution: Check vue-virtual-scroller version and item-size prop
    
    TESTING_SETUP:
      Run unit tests:
        npm run test
      
      Watch mode (auto-rerun on changes):
        npm run test:watch
      
      Generate coverage report:
        npm run test:coverage
      
      Run specific test file:
        npm run test -- src/utils/calculations.spec.ts
    
    DEPLOYMENT_PREREQUISITES:
      ✓ Build succeeds: npm run build (exit code 0)
      ✓ No console warnings or errors
      ✓ dist/ folder contains:
        - index.html
        - assets/[chunk-name].js
        - assets/[chunk-name].css
      ✓ Production build tested locally: npm run preview
      ✓ Bundle size analyzed (< 2MB uncompressed)
      ✓ All TypeScript errors resolved
      ✓ All tests passing

  ============================================================================
  SECTION 5: IMPLEMENTATION STRATEGY
  ============================================================================

  implementation_strategy: |
    
    ================================================================================
    PHASED IMPLEMENTATION PLAN (11 Weeks, 5 Days/Week = 55 Days)
    ================================================================================
    
    PHASE_1_FOUNDATION_2_WEEKS:
      Goal: Establish development environment and basic framework
      
      Week 1: Project Setup
        Days 1-2: Project initialization
          - Create Vue 3 + Vite project
          - Install all dependencies (listed in Section 4)
          - Setup TypeScript strict mode
          - Configure ESLint + Prettier
          - Create .gitignore and git repository
          
          Deliverable: Clean project structure, builds successfully
          Checkpoint: npm run dev starts without errors
        
        Days 3-5: Design System & Layout
          - Create SCSS variables file (colors, spacing, typography)
          - Implement dark theme CSS
          - Create MainLayout component (header, sidebar, content)
          - Create Sidebar navigation component
          - Create Header with placeholder time/filter area
          
          Deliverable: Basic layout framework
          Checkpoint: Layout renders, navigation bar visible
      
      Week 2: State Management & Composables
        Days 1-2: Pinia stores setup
          - Create timeStore.ts (start, end, preset, realtime mode)
          - Create filterStore.ts (active filters, presets)
          - Create metricsStore.ts (metrics data)
          - Create tracesStore.ts (trace data)
          - Create logsStore.ts (log data)
          - Create alertsStore.ts (alert rules + events)
          - Create uiStore.ts (theme, modals, sidebar state)
          
          Deliverable: All stores initialized and working
          Checkpoint: Pinia DevTools shows stores populated
        
        Days 3-5: Core composables
          - useTimeRange.ts (preset selection, custom range)
          - useFilters.ts (apply/clear filters)
          - useChartTheme.ts (ECharts theme config)
          - useLocalStorage.ts (persistence helper)
          
          Deliverable: Reusable composable functions
          Checkpoint: Composables import and use without errors
      
      Phase 1 Success Criteria:
        ✓ Project builds and runs without errors
        ✓ Layout with header and sidebar functional
        ✓ All Pinia stores initialized
        ✓ TypeScript compilation clean
        ✓ ESLint passes with no warnings
    
    ================================================================================
    PHASE_2_MOCK_DATA_GENERATION_1_WEEK:
      Goal: Complete mock data generation system
      
      Week 1: Data generators
        Days 1-2: Time-series generator
          - Implement timeSeriesGenerator.ts
          - Implement sine wave + noise algorithm
          - Test with CPU, error rate, response time configs
          - Verify data realistic (patterns, bounds, distribution)
          - Unit test: 10 cases covering different parameters
          
          Deliverable: Functional time-series generator
          Checkpoint: Generated data matches expected patterns
        
        Days 3: Trace generator
          - Implement traceGenerator.ts
          - Recursive call chain generation (3-10 levels)
          - Error injection (5% rate)
          - Span duration distribution (exponential)
          - Validate trace structure (parent-child relationships)
          
          Deliverable: Functional trace generator
          Checkpoint: 100 generated traces validate correctly
        
        Days 4: Log generator
          - Implement logGenerator.ts
          - Poisson inter-arrival times
          - Time-based density variation
          - Error clustering simulation
          - Level distribution (50% INFO, 30% WARN, 15% ERROR, 5% DEBUG)
          
          Deliverable: Functional log generator
          Checkpoint: Generated logs realistic patterns
        
        Day 5: Mock data initialization
          - Integrate generators into src/mock/index.ts
          - Generate 24h historical data at startup
          - Store in Pinia stores
          - Verify memory usage < 100MB
          - Implement data refresh for real-time mode
          
          Deliverable: Mock data auto-generates on app startup
          Checkpoint: Dashboard loads with mock data visible
      
      Phase 2 Success Criteria:
        ✓ All generators produce realistic data
        ✓ Data volume correct (3 services, 24h history)
        ✓ App starts with data in < 1 second
        ✓ Memory usage acceptable
        ✓ Generators tested with unit tests
    
    ================================================================================
    PHASE_3_CHART_COMPONENTS_1_WEEK:
      Goal: Build all chart wrapper components
      
      Week 1: ECharts components
        Days 1-2: Chart wrappers
          - LineChart.vue (wrapper around ECharts line chart)
          - BarChart.vue (wrapper around ECharts bar chart)
          - PieChart.vue (wrapper around ECharts pie chart)
          - HeatmapChart.vue (wrapper for heatmap)
          - GaugeChart.vue (for KPI displays)
          
          Implementation pattern for each:
            - props: data, config (title, unit, colors), theme
            - methods: initialize ECharts, watch data, watch theme
            - emit: custom events (click, hover)
          
          Deliverable: 5 chart components
          Checkpoint: Charts render with mock data
        
        Days 3-4: Advanced charts
          - FlameGraph.vue (for trace visualization)
          - GanttChart.vue (for timeline visualization)
          - TopologyViewer.vue (integration with AntV G6)
          - ChartContainer.vue (responsive wrapper)
          - ChartLegend.vue (interactive legend)
          
          Deliverable: 5 specialized components
          Checkpoint: Flame chart and Gantt chart render
        
        Day 5: Chart theming + styling
          - Apply dark theme to all charts
          - Configure grid, axis, text styling
          - Verify color palette consistency
          - Test responsive sizing
          
          Deliverable: Themed and responsive charts
          Checkpoint: Visual inspection passes
      
      Phase 3 Success Criteria:
        ✓ All chart types render without errors
        ✓ Dark theme applied consistently
        ✓ Charts responsive to data changes
        ✓ Charts render < 500ms
        ✓ No console errors
    
    ================================================================================
    PHASE_4_FILTER_AND_TIME_COMPONENTS_1_WEEK:
      Goal: Build interactive filter and time selection components
      
      Week 1: Filter components
        Days 1-2: Filter components
          - FilterBar.vue (main container)
          - ServiceFilter.vue (multi-select services)
          - EnvironmentFilter.vue (prod/staging/test)
          - RegionFilter.vue (hierarchical region/zone)
          - InstanceFilter.vue (instance ID autocomplete)
          - TagFilter.vue (custom key-value tags)
          
          Features for each:
            - Multi-select with search
            - Clear individual filter
            - Show selected count
            - Emit changes to parent
          
          Deliverable: 6 filter components
          Checkpoint: Filters apply and emit events
        
        Days 3-4: Time picker components
          - TimeRangePicker.vue (main container)
          - QuickTimeSelect.vue (buttons: 5m, 15m, 1h, 6h, 24h, 7d)
          - CustomDateTimeRange.vue (date + time pickers)
          - RealtimeToggle.vue (toggle + interval selector)
          - TimeComparison.vue (compare with previous period)
          
          Features:
            - Preset buttons with active indicator
            - Date/time picker with validation
            - Real-time toggle and refresh interval
            - Comparison mode toggle
          
          Deliverable: 5 time control components
          Checkpoint: Time controls bind to store
        
        Day 5: Integration + styling
          - Connect filters to filterStore
          - Connect time controls to timeStore
          - Style consistently with design system
          - Test interaction flows
          
          Deliverable: Functional filter/time system
          Checkpoint: Changes propagate to stores
      
      Phase 4 Success Criteria:
        ✓ All filter components interactive
        ✓ Time presets work correctly
        ✓ Custom date range picker functional
        ✓ Real-time mode toggle + interval selector working
        ✓ Filters/time persist to localStorage
    
    ================================================================================
    PHASE_5_DASHBOARD_MODULE_1_WEEK:
      Goal: Complete overview dashboard with all KPI displays
      
      Week 1: Dashboard views
        Days 1-2: Dashboard layout + health board
          - Create views/Dashboard.vue
          - Create HealthBoard.vue (service status cards)
          - Create MetricCard.vue (KPI cards with trend)
          
          Features:
            - 3 service health cards (healthy/warning/critical)
            - 4 KPI cards (error rate, response time, QPS, resource util)
            - Trend indicators (up/down/stable)
            - Click to drill down
          
          Deliverable: Health board + KPI cards
          Checkpoint: Mock data displays correctly
        
        Days 3-4: Dashboard charts + alerts
          - Create AlertPanel.vue (active alert list)
          - Create TrendCharts.vue (4 key metrics over time)
          
          Features for AlertPanel:
            - List of active alerts
            - Severity color coding (red/yellow/blue)
            - Sort by severity
            - Click for detail
          
          Features for TrendCharts:
            - 4 charts (error rate, response time, QPS, resource)
            - Time range selector (1h, 6h, 24h, 7d)
            - Hover tooltips
            - Legend toggles
          
          Deliverable: Alert panel + trend charts
          Checkpoint: Charts render and update with time changes
        
        Day 5: Dashboard integration
          - Assemble all components into Dashboard.vue
          - Bind to stores (time, filters)
          - Test auto-refresh in real-time mode
          - Verify drill-down links work
          
          Deliverable: Complete Dashboard page
          Checkpoint: All components visible and functional
      
      Phase 5 Success Criteria:
        ✓ Service health board displays 3 services
        ✓ 4 KPI cards with valid metrics
        ✓ Alert panel shows 5-10 alerts
        ✓ 4 trend charts render with data
        ✓ Real-time mode updates every 10 seconds
        ✓ Drill-down navigation works
    
    ================================================================================
    PHASE_6_METRICS_MODULE_1_WEEK:
      Goal: Complete detailed metrics analysis module
      
      Week 1: Metrics page
        Days 1-2: Service list + metric display
          - Create views/Metrics.vue (main page layout)
          - Create ServiceList.vue (left panel)
          - Create MetricDetail.vue (right panel)
          
          Features for ServiceList:
            - Searchable list of 3 services
            - Status indicators
            - Click to select
          
          Features for MetricDetail:
            - Display business metrics (error rate, success rate, QPS, P50/P90/P99)
            - Display system metrics (CPU, memory, disk I/O, network)
            - 4 chart type selectors (line, bar, pie, heatmap)
            - Charts update on service/metric selection
          
          Deliverable: Service list + metric charts
          Checkpoint: Charts render for selected service
        
        Days 3-4: Comparison view
          - Create ComparisonView.vue
          - Multi-service metric comparison
          - Time period comparison (current vs previous)
          - Difference calculation
          - Percentage change display
          
          Deliverable: Comparison functionality
          Checkpoint: Comparisons calculate correctly
        
        Day 5: Integration + testing
          - Connect to metricsStore
          - Test data filtering
          - Verify performance (< 500ms per chart)
          - Manual testing of all interactions
          
          Deliverable: Complete Metrics module
          Checkpoint: All features working
      
      Phase 6 Success Criteria:
        ✓ Service list displays all 3 services
        ✓ Business metrics displayed (6 metrics)
        ✓ System metrics displayed (4 metrics)
        ✓ Chart type switching smooth
        ✓ Multi-service comparison working
        ✓ Time period comparison working
    
    ================================================================================
    PHASE_7_TRACING_MODULE_1.5_WEEKS:
      Goal: Complete distributed tracing visualization
      
      Week 1: Trace list + topology
        Days 1-2: Trace list view
          - Create views/Tracing.vue
          - Create TraceList.vue (left panel)
          
          Features:
            - Columns: TraceID, Service, Duration, Status
            - Search by trace ID
            - Filter by status (success/error)
            - Sort by duration, timestamp
            - Click to view detail
          
          Deliverable: Functional trace list
          Checkpoint: Can search and filter traces
        
        Days 3-4: Service topology
          - Create TopologyViewer.vue
          - Integrate AntV G6 library
          - Generate DAG from trace data
          - Render service nodes + edges
          - Add interactivity (pan, zoom, highlight)
          
          Features:
            - Service nodes with status colors
            - Edges with call count + latency
            - Interactive highlighting
            - Click node for details
          
          Deliverable: Service topology graph
          Checkpoint: Graph renders and is interactive
        
        Day 5: Span visualization part 1
          - Create FlameChart.vue (flamegraph visualization)
          - Create GanttChart.vue (timeline visualization)
          
          Deliverable: Partial span visualization
          Checkpoint: Charts render trace data
      
      Week 2: Span details + slow query analysis
        Days 1-2: Span detail view
          - Create SpanDetail.vue
          - Display span info: ID, service, operation, duration
          - Show tags and logs
          - Link to related logs
          
          Deliverable: Span detail panel
          Checkpoint: Span info visible
        
        Days 3-4: Slow query analysis
          - Create SlowQueryAnalysis.vue
          - Detect slow spans (> mean + 2*stdDev)
          - Rank by duration
          - Highlight in visualizations
          - Show bottleneck list
          
          Deliverable: Slow query detection
          Checkpoint: Bottlenecks identified
        
        Day 5: Integration + testing
          - Assemble all components
          - Test cross-component interactions
          - Verify performance
          - Manual end-to-end testing
          
          Deliverable: Complete Tracing module
          Checkpoint: All features working together
      
      Phase 7 Success Criteria:
        ✓ Trace list functional (100+ traces)
        ✓ Topology graph displays services
        ✓ Flamechart shows span timeline
        ✓ Gantt chart shows concurrent spans
        ✓ Span detail fully visible
        ✓ Slow queries highlighted + sorted
        ✓ Performance acceptable (< 500ms)
    
    ================================================================================
    PHASE_8_LOGS_MODULE_1.5_WEEKS:
      Goal: Complete log analytics with virtual scrolling
      
      Week 1: Log stream + search
        Days 1-2: Log stream with virtual scrolling
          - Create views/Logs.vue
          - Create LogStream.vue (virtualized list)
          - Integrate vue-virtual-scroller
          - Render 10,000+ logs smoothly
          
          Features:
            - Smooth scrolling (60 FPS)
            - Color-coded by level
            - Click to expand detail
            - Click traceId to link to trace
          
          Deliverable: Virtual scroll working
          Checkpoint: 10k items scroll without lag
        
        Days 3-4: Search and filter
          - Create LogSearch.vue (search UI)
          - Implement keyword search (regex support)
          - Field filtering (service, level, traceId)
          - Advanced query builder (optional)
          - Search history + saved searches
          
          Features:
            - Keyword input with regex
            - Multi-select filters
            - Clear/reset buttons
            - Show result count
          
          Deliverable: Search functional
          Checkpoint: Correct logs returned
        
        Day 5: Log detail view
          - Create LogDetail.vue
          - Show full message + context
          - Show surrounding logs (prev/next N)
          - Link to traceId
          - Copy to clipboard
          
          Deliverable: Log detail panel
          Checkpoint: Full log context visible
      
      Week 2: Log statistics
        Days 1-2: Statistics views
          - Create LogStatistics.vue
          - Log count trend (line chart)
          - Level distribution (pie chart)
          - Time-series aggregation
          
          Deliverable: Statistics charts
          Checkpoint: Stats match underlying data
        
        Days 3-4: Search optimization
          - Implement debounced search
          - Cache search results
          - Optimize filter application
          - Test performance
          
          Deliverable: Optimized search
          Checkpoint: Search response < 200ms
        
        Day 5: Integration + testing
          - Assemble all components
          - Test virtual scrolling with 10k items
          - Verify performance metrics
          - Manual end-to-end testing
          
          Deliverable: Complete Logs module
          Checkpoint: All features working
      
      Phase 8 Success Criteria:
        ✓ Log stream renders 10,000+ items
        ✓ Virtual scrolling smooth (60 FPS)
        ✓ Keyword search works with regex
        ✓ Field filtering accurate
        ✓ Log detail shows full context
        ✓ Statistics calculated correctly
        ✓ Search response < 200ms
    
    ================================================================================
    PHASE_9_CUSTOM_DASHBOARD_1_WEEK:
      Goal: User-configurable dashboard builder
      
      Week 1: Drag-drop + templates
        Days 1-2: Drag-drop layout engine
          - Create views/Custom.vue
          - Create DragDropGrid.vue (grid layout)
          - Implement 12-column grid system
          - Drag widgets to reposition
          - Resize widgets with handles
          - Min/max size constraints
          
          Features:
            - Auto-snap to grid
            - Undo/redo support
            - Auto-save to localStorage
          
          Deliverable: Functional drag-drop
          Checkpoint: Widgets move and resize smoothly
        
        Days 3: Chart configuration
          - Create ChartConfig.vue (modal)
          - Data source selector
          - Metric selector
          - Chart type selector
          - Threshold configuration
          - Real-time preview
          
          Deliverable: Configuration modal
          Checkpoint: Configuration updates preview
        
        Days 4-5: Templates + persistence
          - Create TemplateGallery.vue
          - Predefined templates (app, infra, business)
          - Save dashboard to localStorage
          - Load saved dashboards
          - Export/import as JSON
          
          Deliverable: Complete custom dashboard
          Checkpoint: Configurations persist
      
      Phase 9 Success Criteria:
        ✓ Drag-drop works smoothly
        ✓ Widgets resizable
        ✓ Chart configuration functional
        ✓ Templates applicable
        ✓ Save/load working
        ✓ Undo/redo functional
        ✓ Persistence to localStorage
    
    ================================================================================
    PHASE_10_CROSS_MODULE_LINKING_1_WEEK:
      Goal: Implement seamless navigation between modules
      
      Week 1: Linkage + drill-down
        Days 1-2: Router setup + linkage
          - Setup Vue Router (index.ts)
          - Define all routes
          - Query parameter handling
          - Implement linkage functions:
            - navigateToTrace(service, timeRange)
            - navigateToLogs(traceId, service)
            - navigateToDashboard()
          
          Deliverable: Router functional
          Checkpoint: Navigation between pages works
        
        Days 3-4: Metric drill-down
          - Click metric chart → Metrics page
          - Click metric anomaly → Tracing page (filtered)
          - Click service card → Metrics detail
          - Pre-apply filters on navigation
          
          Deliverable: Metric drill-down working
          Checkpoint: Navigation + filtering linked
        
        Days 5: Trace/Log linkage
          - Span → Logs navigation
          - Log → Trace navigation (via traceId)
          - Breadcrumb navigation
          - State preservation across modules
          - Add back button functionality
          
          Deliverable: Complete cross-module linking
          Checkpoint: All linkages functional
      
      Phase 10 Success Criteria:
        ✓ Navigation between modules smooth
        ✓ Query parameters preserve context
        ✓ Filters pre-applied on drill-down
        ✓ Breadcrumb navigation functional
        ✓ Back button works
        ✓ State preserved across modules
        ✓ No missing drill-down paths
    
    ================================================================================
    PHASE_11_OPTIMIZATION_AND_REFINEMENT_1_WEEK:
      Goal: Performance optimization, polish, and documentation
      
      Week 1: Optimization + delivery
        Days 1-2: Performance optimization
          - Profile with Chrome DevTools
          - Optimize chart rendering (aggregation)
          - Optimize virtual scrolling
          - Code splitting by route
          - Lazy load heavy components
          - Minify and optimize bundle
          
          Measurement:
            - First load < 2s
            - Page transition < 300ms
            - Chart render < 500ms
            - Data refresh < 200ms
          
          Deliverable: Performance targets met
          Checkpoint: All metrics pass targets
        
        Days 3: Refinement
          - Animation tweaking (300-500ms)
          - Loading state improvements
          - Error handling + messages
          - Accessibility checks
          - Browser compatibility test
          
          Deliverable: Polished UI/UX
          Checkpoint: Professional appearance
        
        Days 4-5: Documentation + delivery
          - Write README.md with setup guide
          - Document mock data generators
          - Document component APIs
          - Document deployment
          - Create CHANGELOG
          - Build production bundle
          - Verify bundle size < 2MB gzipped
          
          Deliverable: Complete project with documentation
          Checkpoint: Ready for production deployment
      
      Phase 11 Success Criteria:
        ✓ All performance targets met
        ✓ Smooth animations throughout
        ✓ Professional visual appearance
        ✓ Documentation complete
        ✓ No build errors or warnings
        ✓ Bundle size optimized
        ✓ Production build successful
        ✓ Demo data comprehensive
    
    ================================================================================
    DAILY DEVELOPMENT WORKFLOW
    ================================================================================
    
    Morning Standup (15 minutes):
      - Review yesterday's progress
      - Identify blockers
      - Plan today's tasks
      - Verify test environment
    
    Development (6-7 hours):
      - Work on assigned phase tasks
      - Commit code frequently (per feature)
      - Write unit tests as you go
      - Fix issues immediately
    
    Testing (1 hour):
      - Run test suite
      - Manual testing of features
      - Visual inspection
      - Performance check
    
    Documentation (30 minutes):
      - Update code comments
      - Document decisions
      - Update task tracking
    
    Code Review (optional):
      - Self-review before commit
      - Check for TypeScript errors
      - Verify test coverage
    
    ================================================================================
    RISK MITIGATION STRATEGIES
    ================================================================================
    
    RISK: Mock data generation too slow
      Mitigation: Generate once at startup, cache in Pinia, reuse
    
    RISK: ECharts rendering performance degradation
      Mitigation: Enable sampling for >2000 points, use aggregation
    
    RISK: Virtual scrolling not smooth enough
      Mitigation: Use vue-virtual-scroller library (proven solution)
    
    RISK: Pinia store mutations too frequent
      Mitigation: Debounce updates, batch mutations
    
    RISK: Complex state management bugs
      Mitigation: Strong TypeScript types, unit test stores
    
    RISK: Cross-module state synchronization issues
      Mitigation: Single source of truth (Pinia), watchers for propagation
    
    RISK: Browser compatibility issues
      Mitigation: Test on Chrome, Firefox, Edge; use polyfills if needed
    
    RISK: Lost productivity on minor UI bugs
      Mitigation: Focus on functionality first, polish later
    
    ================================================================================
    SUCCESS METRICS & COMPLETION CRITERIA
    ================================================================================
    
    Code Metrics:
      ✓ TypeScript strict mode passes (100% type coverage)
      ✓ ESLint passes with no errors or warnings
      ✓ No console errors or warnings on startup
      ✓ Code duplication < 5%
    
    Functional Metrics:
      ✓ All 47 components implemented
      ✓ All 5 modules functional
      ✓ All tests passing (unit + integration)
      ✓ No critical bugs
    
    Performance Metrics:
      ✓ First load < 2 seconds
      ✓ Page transition < 300ms
      ✓ Chart render < 500ms
      ✓ Real-time refresh < 200ms
      ✓ Virtual scroll 60 FPS sustained
      ✓ Memory < 150MB
    
    Quality Metrics:
      ✓ Test coverage > 70%
      ✓ No major accessibility issues
      ✓ Responsive at 1920x1080 and 2560x1440
      ✓ Professional visual appearance (matches Grafana 80%+)
    
    Delivery Metrics:
      ✓ Documentation complete
      ✓ README with setup guide
      ✓ Clean git history
      ✓ Production build successful
      ✓ No security vulnerabilities
    
    Project Success = All metrics ✓
```

---

## IMPLEMENTATION COMPLETE

This comprehensive reproduction plan provides everything needed to build the **Observability Monitoring Platform** without reading the original requirements document.

### Key Takeaways:

1. **File Structure**: 20 core files + tests + docs, organized by functionality
2. **Algorithms**: 3 sophisticated data generators (time-series, traces, logs) with complete pseudocode
3. **Components**: 47 total components across 5 modules with detailed specifications
4. **Performance**: Clear targets (< 2s load, < 300ms transitions, 60 FPS scroll)
5. **Timeline**: 11-week phased approach with daily milestones
6. **Validation**: Comprehensive testing strategy with expected results

**Total Implementation Scope**: ~4000 hours of detailed specifications for a skilled Vue 3 developer to execute independently.